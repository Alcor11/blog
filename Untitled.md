# 分布式

## 概念理论

### CAP

- 一致性 C: Consistency
  - 写操作完成后，读操作可以读取到最新的数据状态。
- 可用性 A：Availability
  - 任何操作都可以得到响应结果
- 分区容错性 P：Partition tolerance
  - 节点之间通信失败，此时仍可以对外提供服务

- **一致性如何实现**
  主数据库写入成功，则从数据库查询也应该成功

1. 主数据库写入数据需要同步到从库
2. 写入主库后，在向从库同步期间需要给从库加锁，等待同步完成后再释放锁。

- **一致性特点**

1. 写操作存在一定的延迟
2. 需要等待数据同步完成后再进行锁施放
3. 如果请求同步失败的节点，需要返回错误信息，而不是旧数据

- **可用性目标**

1. 从库接收到查询请求一定返回结果
2. 数据库不允许出现相应超时

- **如何实现可用性**

1. 主库写入数据需要同步到从库
2. 保证数据库的可用性，不能锁定资源
3. 如果数据没有同步过来，也要返回旧数据，不能返回错误。

- **分区容错性的目标**

1. 主数据库同步从数据库失败不影响写操作
2. 其中一个节点挂掉不会影响另一个节点对外提供服务

- **如何实现分区容错性**

1. 使用异步代替同步操作，使用异步方式将数据从主数据库同步到从数据库，松耦合
2. 添加数据库节点，即使一个从节点挂掉也可以由其他节点提供服务。

- **为什么不能同时满足CAP**

1. 可用性和一致性需要取舍。

### BASE

Basically Available 基本可用 Soft state 软状态 Eventually consistent 最终一致性

- 是对CAP中一致性和可用性权衡的结果，核心思想是：即使无法做到强一致性，但是每个应用可以根据自身业务特点，采用适当方式达到最终一致性。
- **Basically Available 基本可用**
  是指当系统出现故障的时候，允许损失部分可用性

1. 响应时间损失：运势响应时间延长
2. 功能损失：允许部分非核心功能损失

- **Soft state 软状态**
  允许系统中数据存在中间状态，并认为该状态不影响整体可用性
  允许系统在多个不同节点的数据副本之间进行数据同步的过程中存在延迟。

- **Eventually consistent 最终一致性**
  是指所有的数据副本，在经过一段时间同步后，能够达到一致状态，而不是实时保证强一致性。

- **ELK**
  是一套日志收集系统
  Elasticsearch 存储检索日志
  Logstash 日志收集
  Kibana 提供分析界面

Filebeat

 - Packetbeat 搜集网络流量数据
 - Topbeak 搜集系统文件数据
 - Filebeat 搜集文件数据
 - Winlogbeat 搜集windows时间日志数据

- **分布式协议**

1. **事务协议**：两阶段提交协议、三阶段提交协议
2. **一致性协议**：Paxos、Raft
3. **复活协议**：心跳包协议、租约协议
4. **复制协议**：主从复制协议、NWR复制协议、Replicated-write协议

- **一致性协议：**
  目的是为了保证数据一致性
  Paxos：用来保障当主节点发生故障的时候，如何从从节点中选举出主节点。
  只有一个提议者：提议者发送请求给接受者，接受者统一超过一半则生效。

**Raft协议：**
模块：
领导人选举、日志复制、安全性
领导人处理所有的客户端请求，候选人
追随者：简单响应来自领导人和候选人请求。
当跟随者长时间没收到来自领导人的心跳包或候选人的请求投票RPC时，便会成为候选人发起投票。

- **分布式容错**

1. 心跳包协议：
   1. 在心跳包上添加信息
2. 租约协议



- **分布式事务**

3. 事务协议：2PC 3PC
4. 目的是为了保证数据的一致性，实际就是把耽搁数据库的事务扩大到了对多个库的事务。
5. 协议：两阶段提交协议
   - 引入协调者，操作者将操作是否成功通知协调者。
   - 准备阶段：协调者发送消息给操作者询问操作者是否可以提交，操作者全部返回是，则提交，如果有一个否，则全部回滚。
   - 操作者在本地准备好redu和undo日志。

- 2pc存在的问题：同步阻塞问题，在未提交的时候，所有操作者都会阻塞
  - 单点故障：一旦协调者出现故障，参与者就会一直阻塞
  - 数据不一致：如果在发送commit的过程中网络异常，则会数据不一致。
- 3pc：引入超时机制，prepare commit、pre commit阶段，do commit三个阶段


- 分片

- 长链接

- 多线程

- 无锁机制

依赖的中间件越多可靠性越差、链路越长实时性越差，所以可以再想想