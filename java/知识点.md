# Java基础✅

## 语法基础🙏

### 构造器是否可以私有？

可以- 单例模式、枚举类


### 类型

#### 基本类型和引用类型的区别

1. 基本类型：int double char boolean long float等基本类型
2. 引用类型：类类型，接口、数组等

3. 基本类型和引用类型中保存的信息
   基本类型中保存的是值
   引用类型中保存的是该类型在堆中的地址，表示对该对象的引用，而不是真正的该对象。
4. 创建的时候的区别
   基本类型在创建的时候会直接赋值，并分配值的空间
   引用类型创建的时候只会分配引用的空间，而不分配数据空间，大概是4byte

#### java中只有值传递没有引用传递

因为引用类型中保存的信息是引用对象的首地址，并没有存储对象的信息，在作为实参传递的时候，传递的是引用的值



- JAVA.lang

  - NumberFormat  数值format方法
    - getCurrencyInstance() 转换为钱的格式
    - getPercentInstance()转换为百分比格式 %

- JAVA.util

  - scanner  获得系统输入

  ```jsx
  Scanner scanner = new Scanner(System.in);
  ```

#### 按位或与逻辑或

```tex
这道题主要考的是"|"与"||"的区别
用法：condition 1 | condition 2、condition 1 || condition 2
"|"是按位或：先判断条件1，不管条件1是否可以决定结果（这里决定结果为true)，都会执行条件2
"||"是逻辑或：先判断条件1，如果条件1可以决定结果（这里决定结果为true)，那么就不会执行条件2
```

#### java基础类型和长度

```java
	byte // 字节  1字节 8位。-128 - 127  -2^7 - 2^7-1
  short // 短整形 2字节 16位。 -32768 - 32767 -2^16 - 2^16-1
  int // 4 字节 32位 -2147483648  -2^31 - 2^31-1
  long // 长 64位  -2^63 - 2^63-1
  float // 32位 浮点数  -3.4*E38- 3.4*E38 默认值是0.0f；
  double // 64位 -1.7E308～1.7E308
  char // 0-65535  \u0000 - \uffff
  boolean // true false
```

- 基本数据类型：
  - byte 1字节 8 位。 -128 - 127  -2^7 —2^7 - 1
  - short：2字节（16位），数据范围是 -2^15 ~ 2^15-1。
  - int：4字节（32位），数据范围是 -2^31 ~ 2^31-1。
  - long：8字节（64位），数据范围是 -2^63 ~ 2^63-1。
  - float：4字节（32位），数据范围大约是 -3.4*10^38 ~ 3.4*10^38。
  - double：8字节（64位），数据范围大约是 -1.8*10^308 ~ 1.8*10^308。
  - char：2字节（16位），数据范围是 \u0000 ~ \uffff。
  - boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。
- 基本数据类型有默认值：为0， boolean为false char为'\u0000'
- 包装类继承object类，拥有自动装箱和自动拆箱的功能。
- 判断Integer 和 Double相等
  - 不能直接==判断，因为不是相同的数据类型
  - 也不能直接转成字符串，因为Double中的小数点也会被转为字符串
  - compareTo方法只能与相同类型
  - 由于都是基于Number类。因此需要先将他们转为同一类型，如：Double，然后用==

```java
Integer i = 100;
Double d = 100.00;
System.out.pringln(i.doubleValue() == d.doubleValue())
```

- 基本数据类型与其包装类直接进行==运算时会自动拆箱。将Integer转为int基本数据类型进行比较。

### compareTo

如果需要`Arrays.sort()`对某个对象进行排序，则该对象必须实现`Comparable`接口。

`.compareTo()`应与`.equals()`方法兼容。但是有特例：

```java
x = new BigDecimal("1.0");
y = new BigDecimal("1.00");
x.equals(y); // false 精度不同
x.compareTo(y); // 0
```

### == 与 .equals()

> ==运算符：

- 作用于基本数据类型时，是比较两个数值是否相等；
- 作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；

> equals()方法：

- 没有重写时，Object默认以 == 来实现，即比较两个对象的内存地址是否相同；
- 进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。

> 计算42度（角度）的余弦值？

```
因为Math.cos中的参数的单位是弧度
而你的42是角度，所以要先把42化成弧度，Math.toRadians就是把角度化成弧度
```

```
double d = Math.cos(Math.toRadians(42))
```

> `a = a + b `与 `a += b`的区别

- `+=` 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。

```java
byte a = 127;
byte b = 127;
b = a + b; // error : cannot convert from int to byte
b += a; // ok
```

> `a + b`的时候`a`和`b`会自动转换为int类型，但是当int类型赋值给byte时会报错。`b = (byte) a + b`

- `b += a`会自动向高精度进行数据类型转换。

> 3*0.1 == 0.3 将会返回什么? true 还是 false?

- false，因为有些浮点数不能完全精确的表示出来。

https://www.zhihu.com/question/56545018

### integer

Integer类赋值的范围在-128 - 127之间时，是被缓存的，地址相同，在这个范围内== 相等则为true

范围外则创建对象

### hashcode 和 equals

> **为什么在重写 equals 方法的时候需要重写 hashCode 方法**?

> 因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。

hashCode()用于获取哈希码（散列码），eauqls()用于比较两个对象是否相等，它们应遵守如下规定：

- 如果两个对象相等，则它们必须有相同的哈希码。
- 如果两个对象有相同的哈希码，则它们未必相等。

在Java中，Set接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。

HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。

- HashSet判断即将插入的内容是否已经存在是先判断哈希码是否存在，再判断.equals()是否相等。若相等，则使用链式方式解决哈希冲突。

### 关于final和抽象类

1、抽象类不能被**实例化**，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。

2、抽象方法必须由子类来进行重写。

3、只要包含一个抽象方法的类，该类必须要定义成抽象类，不管是否还包含有其他方法。

4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。

5、abstract不能与final并列修饰同一个类。

6、abstract 不能与private、static、final或native并列修饰同一个方法。、

### 接口与抽象类

- 一个子类只能继承一个抽象类, 但能实现多个接口
- 抽象类可以有构造方法, 接口没有构造方法
- 抽象类可以有普通成员变量, 接口没有普通成员变量
- 抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)
- 抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法
- 抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）
- 抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法

### this() & super()在构造方法中的区别？

- 调用`super()`必须写在子类构造方法的**第一行**, 否则编译不通过
- `super`从子类调用父类构造, `this`在同一类中调用其他构造均需要放在第一行
- 尽管可以用`this`调用一个构造器, 却不能调用2个
- `this`和`super`不能出现在同一个构造器中, 否则编译不通过
- `this()、super()`都指的对象,不可以在`static`环境中使用
- 本质`this`指向本对象的**指针**。`super`是一个**关键字**

### String类

```java
// jdk 1.7后
String a1 = new String("abc") + new String("def");
String b1 = a1.intern();
String c1 = "abcdef";
System.out.println(a1 == c1); // true
System.out.println(b1 == c1); // true

// jdk 1.6
System.out.println(a1 == c1); // false
System.out.println(b1 == c1); // true
```



- 在jvm1.6时，字符串常量池放在永久代中



![image-20220416184102046](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220416184102046.png)

- String类方法

- ```java
  char charAt(int index); // 返回指定位置的字符
  
  String substring(int beginIndex, int endIndex) // 从此字符串中截取出一部分子字符串
    
  String[] split(String regex) // 以指定规则将字符串分割成数组
    
  String trim() // 删除字符串前导和后置的空格；
    
  int indexOf(String str) // 返回子串在此字符串首次出现的索引；
    
  int lastIndexOf(String str) // 返回子串在此字符串最后出现的索引；
    
  boolean startsWith(String prefix) // 判断此字符串是否以指定的前缀开头；
  
  boolean endsWith(String suffix) // 判断此字符串是否以指定的后缀结尾；
  
  String toUpperCase() // 将此字符串中所有的字符大写；
  
  String toLowerCase() // 将此字符串中所有的字符小写；
  
  String replaceFirst(String regex, String replacement) // 用指定字符串替换第一个匹配的子串；
  
  String replaceAll(String regex, String replacement) // 用指定字符串替换所有的匹配的子串。
  ```

- String类由final修饰，不能被继承。

- String不可变。线程安全。“修改”则会产生一个新的字符串对象。

- java9以前使用private final char[] value，java9后使用private final byte[] value

> 采用StringBuilder/StringBuffer拼接字符串时：

- StringBuilder/StringBuffer都有字符串缓冲区，缓冲区的容量在创建对象时确定，并且默认为16。当拼接的字符串超过缓冲区的容量时，会触发缓冲区的扩容机制，即缓冲区加倍。
- 缓冲区频繁的扩容会降低拼接的性能，所以如果能提前预估最终字符串的长度，则建议在创建可变字符串对象时，放弃使用默认的容量，可以指定缓冲区的容量为预估的字符串的长度。

> 采用String类的concat方法拼接字符串时：

- concat方法的拼接逻辑是，先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。
- 在拼接大量字符串的时候，concat方法的效率低于StringBuilder。但是只拼接2个字符串时，concat方法的效率要优于StringBuilder。并且这种拼接方式代码简洁，所以**只拼2个字符串时建议优先选择concat方法**。

> 字符串相加的底层

如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的。

如果拼接的字符串中包含变量，则在编译时**编译器采用StringBuilder**对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起。

> 对string赋值 String a = "abc";

- JVM使用常量池来管理字符串的直接量。执行时JVM会先检查常量池中是否有"abc"，若没有则存入，否则直接复用，将其引用赋值给a

> new String("abc") 是去了哪里，仅仅是在堆里面吗？

- 在执行这句话时，JVM会先使用常量池来管理字符串直接量，即将"abc"存入常量池。然后再创建一个新的String对象，这个对象会被保存在堆内存中。并且，堆中对象的数据会指向常量池中的直接量。

> 字符串拼接

- ‘ + ’ 运算符 适合字符串直接量
  - 如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的，所以效率非常的高。
- StringBuilder：包含变量，且不要求线程安全
- StringBuffer： 包含变量，且要求线程安全
  - 若在循环中使用，则效率很低，每次循环编译都会创建一个StringBuilder实例，相当于执行了new StringBuilder().append(str)
- String类的concat方法：对2个字符串进行拼接，并且包含变量

### Java移位运算符

- `<<` :左移运算符,`x << 1`,相当于x乘以2(不溢出的情况下),低位补0
- `>>` :带符号右移,`x >> 1`,相当于x除以2,正数高位补0,负数高位补1
- `>>>` :无符号右移,忽略符号位,空位都以0补齐

### finally块

不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。

- 如果在try块或catch块中使用 System.exit(1); 来退出虚拟机，则finally块将失去执行的机会。但是我们在实际的开发中，都不会这样做，所以尽管存在这种导致finally块无法执行的可能，也只是一种可能而已。

- 在通常情况下，不要在finally块中使用return、throw等导致方法终止的语句，一旦在finally块中使用了return、throw语句，将会导致try块、catch块中的return、throw语句失效。

### static关键字的理解

在Java类里只能包含成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5种成员，而static可以修饰**成员变量、方法、初始化块、内部类**（**包括接口、枚举**），**以static修饰的成员就是类成员**。类成员属于整个类，而不属于单个对象。

- **类成员（包括成员变量、方法、初始化块、内部类和内部枚举）不能访问实例成员（包括成员变量、方法、初始化块、内部类和内部枚举）**。因为类成员是属于类的，类成员的作用域比实例成员的作用域更大，完全可能出现类成员已经初始化完成，但实例成员还不曾初始化的情况，如果允许类成员访问实例成员将会引起大量错误。
- static修饰的类可以被继承



静态内部类需满足如下规则：

1. 静态内部类可以包含静态成员，也可以包含非静态成员；
2. 静态内部类不能访问外部类的实例成员，只能访问它的静态成员；
3. 外部类的所有方法、初始化块都能访问其内部定义的静态内部类；
4. 在外部类的外部，也可以实例化静态内部类，语法如下：

#### static与final区别

static关键字可以修饰成员变量、成员方法、初始化块、内部类，被static修饰的成员是类的成员，它属于类、不属于单个对象。以下是static修饰这4种成员时表现出的特征：

- 类变量：被static修饰的成员变量叫类变量（静态变量）。类变量属于类，**它随类的信息存储在方法区**，**并不随对象存储在堆中**，类变量可以通过类名来访问，也可以通过对象名来访问，**但建议通过类名访问它**。

- 类方法：被static修饰的成员方法叫类方法（静态方法）。类方法属于类，可以通过类名访问，也可以通过对象名访问，**建议通过类名访问它**。

- 静态块：被static修饰的初始化块叫静态初始化块。静态块属于类，**它在类加载的时候被隐式调用一次**，**之后便不会被调用了**。

- 静态内部类：被static修饰的内部类叫**静态内部类**。静态内部类**可以包含静态成员**，也可以包含**非静态成员**。静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。外部类的所有方法、初始化块都能访问其内部定义的静态内部类。

  

final关键字可以修饰类、方法、变量，以下是final修饰这3种目标时表现出的特征：

- final类：final关键字修饰的类**不可以被继承**。
- final方法：final关键字修饰的方法**不可以被重写**。
- final变量：final关键字修饰的变量，**一旦获得了初始值，就不可以被修改**。

#### 变量分为成员变量、局部变量。

final修饰成员变量：

- 类变量：可以在声明变量时指定初始值，也可以在静态初始化块中指定初始值；
- 实例变量：可以在声明变量时指定初始值，也可以在初始化块或构造方法中指定初始值；

final修饰局部变量：

- 可以在声明变量时指定初始值，也可以在后面的代码中指定初始值。

  *注意：被 final 修饰的任何形式的变量，一旦获得了初始值，就不可以被修改！*

### 值传递与引用传递英文

call by value

call by reference

- **值传递**是将变量的一个副本传递到方法中，方法中如何操作该变量副本，都不会改变原变量的值。
- **引用传递**是将变量的内存地址传递给方法，方法操作变量时会找到保存在该地址的变量，对其进行操作。会对原变量造成影响。

### lambda表达式

带参数变量的表达式被称为lambda表达式

```java
(String first, String second) -> {
  return 0;
}

() -> {
  // do something here
}
```

```java
Comparator<String> comp = (first, second)
  -> first.length() - second.length();
```

- 将println传到Timer构造器中

```java
var timer = new Timer(1000, System.out::println);
```

- 想对字符串排序，并不考虑字母的大小写。

```java
Arrays.sort(strings, String::compareToIgnoreCase);
```

![image-20220418193629934](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220418193629934.png)

- 用`::`运算符分隔方法名与对象类名。
  1. `x -> System.out.println(x)`
  2. `String::compareToIgnoreCase  等同于  (x,y)->x.compareToIgnoreCase(y);`
  3. 将参数传递到静态方法`Math::pow 等同于 (x,y)->Math.pow(x,y)`

- 从list中移除为null的对象
  - `list.removeIf(Object::isNull)`

- this和super也是合法的方法引用参数
  - `this::equals`

### 闭包（closure）

lambda表达式就是闭包

- lambda表达式能够捕获外部作用域中变量的值，但是必须确保该值是明确定义的。在lambda表达式中只能引用值不会改变的变量。（并发执行不安全）
- 以下不合法。

![image-20220418202815437](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220418202815437.png)

### Comparator

- 使用Comparator中的静态方法实现排序

```java
Arrays.sort(people, Comparator.comparing(Person::getName));
```

## java泛型😓

Java 5以前，java集合中的对象会使用 Object类型，为了能够存储多种对象。

- 集合对元素类型没有任何限制，这样可能引发一些问题。例如，想创建一个只能保存Dog对象的集合，但程序也可以轻易地将Cat对象“丢”进去，所以可能引发异常。
- 由于把对象“丢进”集合时，集合丢失了对象的状态信息，只知道它盛装的是Object，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发ClassCastException异常。

从Java 5开始，Java引入了“参数化类型”的概念，允许程序在创建集合时指定集合元素的类型，Java的参数化类型被称为**泛型**（Generic）。例如 `List<String>`，表明该List只能保存字符串类型的对象。

有了泛型以后，程序再也不能“不小心”地把其他对象“丢进”集合中。而且程序更加简洁，集合自动记住所有集合元素的数据类型，**从而无须对集合元素进行强制类型转换。**

> 范型的类型在使用时指定，不需要强制类型转换。

### 定义一个泛型类

- 简单泛型

```java
class Point<T>{         // 此处可以随便写标识符号，T是type的简称  
    private T var ;     // var的类型由T指定，即：由外部指定  
    public T getVar(){  // 返回值的类型由外部决定  
        return var ;  
    }  
    public void setVar(T var){  // 设置的类型也由外部决定  
        this.var = var ;  
    }  
}  
public class GenericsDemo06{  
    public static void main(String args[]){  
        Point<String> p = new Point<String>() ;     // 里面的var类型为String类型  
        p.setVar("it") ;                            // 设置字符串  
        System.out.println(p.getVar().length()) ;   // 取得字符串的长度  
    }  
}
```

- 多元泛型

```java
class Notepad<K,V>{       // 此处指定了两个泛型类型  
    private K key ;     // 此变量的类型由外部决定  
    private V value ;   // 此变量的类型由外部决定  
    public K getKey(){  
        return this.key ;  
    }  
    public V getValue(){  
        return this.value ;  
    }  
    public void setKey(K key){  
        this.key = key ;  
    }  
    public void setValue(V value){  
        this.value = value ;  
    }  
} 
public class GenericsDemo09{  
    public static void main(String args[]){  
        Notepad<String,Integer> t = null ;        // 定义两个泛型类型的对象  
        t = new Notepad<String,Integer>() ;       // 里面的key为String，value为Integer  
        t.setKey("汤姆") ;        // 设置第一个内容  
        t.setValue(20) ;            // 设置第二个内容  
        System.out.print("姓名；" + t.getKey()) ;      // 取得信息  
        System.out.print("，年龄；" + t.getValue()) ;       // 取得信息  
  
    }  
}
```

- 定义泛型接口

```java
interface Info<T>{        // 在接口上定义泛型  
    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  
}  
class InfoImpl<T> implements Info<T>{   // 定义泛型接口的子类  
    private T var ;             // 定义属性  
    public InfoImpl(T var){     // 通过构造方法设置属性内容  
        this.setVar(var) ;    
    }  
    public void setVar(T var){  
        this.var = var ;  
    }  
    public T getVar(){  
        return this.var ;  
    }  
} 
public class GenericsDemo24{  
    public static void main(String arsg[]){  
        Info<String> i = null;        // 声明接口对象  
        i = new InfoImpl<String>("汤姆") ;  // 通过子类实例化对象  
        System.out.println("内容：" + i.getVar()) ;  
    }  
}  
```

- 调用泛型方法格式

`Generic generic = new Generic();`

`Object obj = generic.getObject(Class.forName("com.xxx.test.user"))`

### 泛型的上限和下限？

- 可以为传入的实参进行上下边界的限制：

```java
// 只允许传入父类为XX的类型 上限
class Info<T extends Number>{    // 此处泛型只能是数字类型
    private T var ;        // 定义泛型变量
    public void setVar(T var){
        this.var = var ;
    }
    public T getVar(){
        return this.var ;
    }
    public String toString(){    // 直接打印
        return this.var.toString() ;
    }
}
public class demo1{
    public static void main(String args[]){
        Info<Integer> i1 = new Info<Integer>() ;        // 声明Integer的泛型对象
    }
}

// 下限
class Info<T>{
    private T var ;        // 定义泛型变量
    public void setVar(T var){
        this.var = var ;
    }
    public T getVar(){
        return this.var ;
    }
    public String toString(){    // 直接打印
        return this.var.toString() ;
    }
}
public class GenericsDemo21{
    public static void main(String args[]){
        Info<String> i1 = new Info<String>() ;        // 声明String的泛型对象
        Info<Object> i2 = new Info<Object>() ;        // 声明Object的泛型对象
        i1.setVar("hello") ;
        i2.setVar(new Object()) ;
        fun(i1) ;
        fun(i2) ;
    }
    public static void fun(Info<? super String> temp){    // 只能接收String或Object类型的泛型，String类的父类只有Object类
        System.out.print(temp + ", ") ;
    }
}
```

### 泛型擦除

当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉。比如一个 `List<String>` 类型被转换为List，则该List对集合元素的类型检查变成了泛型参数的上限（即Object）。

解决了C++中可能会存在的模板代码膨胀问题。

```java
List<String> list1 = ...; List list2 = list1; // list2将元素当做Object处理
```

从逻辑上来看，`List<String>` 是List的子类，如果直接把一个List对象赋给一个`List<String>`对象应该引起编译错误，但实际上不会。对泛型而言，可以直接把一个List对象赋给一个 List`<String> `对象，编译器仅仅提示“未经检查的转换”。

上述规则叫做泛型转换，可以通过下面代码进一步理解泛型转换：

```
List list1 = ...; List<String> list2 = list1; // 编译时警告“未经检查的转换”
```

![image-20220420214109840](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220420214109840.png)

### `List<? super T>`和`List<? extends T>`有什么区别？

- ? 是类型通配符，`List<?>` 可以表示各种泛型List的父类，意思是元素类型未知的List；
- `List<? super T>` 用于设定类型通配符的下限，此处 ? 代表一个未知的类型，但它必须是T的父类型；
- `List<? extends T>` 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是T的子类型。

### 泛型注意点

1. 虚拟机中没有泛型，只有普通的类和方法，在编译的时候会泛型擦除。
2. 所有的类型参数都会替换为限定类型，无限定则为`Object`
3. 必要时会插入强制类型转换。

### 由类型擦除导致的限制

1. 不能用基本类型代替类型参数。对于基本类型必须使用包装类型。因为类型擦除，泛型类只包含Object类型的字段。 
2. 由于虚拟机中的对象总有一个特定的非泛型类型的对象，因此所有类型查询只有原始类型。

```java
if (a.instanceof Pair<T>) // error
```

- 不能查询某个对象是否为某个泛型
- 不允许创建参数化类型的数组
  - 因为编译时会擦除类型，导致错误
- 可以设置通配符类型的数组，然后进行强制类型转换：

```java
var table = (Pair<String>[])  new Pair<?>[10];
```

![image-20220421204926111](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220421204926111.png)

![image-20220421210253864](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220421210253864.png)

### 通配符类型

`Pair<? extends Employee>`

- 表示任何泛型`Pair`类型参数都是Employee的子类。

```java
public static void printBuddies(Pair<Employee> p) {
  Employee first = p.getFirst();
  Employee second = p.getSecond();
  sout(fir....)
}
```

![image-20220421210853715](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220421210853715.png)



## 注解👊

> 注解是java1.5中引入的特性。

- 作用：
  - 生成文档，通过代码里标识的元数据生成javadoc文档。
  - 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。
  - 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。
  - 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例

### 注解分类

- Java自带注解：
  - `@Override`  用于标明重写某个方法
  - `@Deprecated` 标明某个类或方法过时、标明要忽略的警告 
  - `@SuppressWarnings`、用这些注解标明后编译器就会进行检查

- 元注解
  - `@Retention`用于标明注解被保留的阶段
  - `@Target`用于标明注解使用的范围
  - `@Inherited`用于标明注解可继承
  - `@Documented`用于标明是否生成javadoc文档
- 自定义注解

## 异常👈

### 异常类的层次

- 所有错误与异常的超类：`Throwable`
  - Error类及其子类：严重错误
  - Exception：程序本身可以捕获并且可以处理的异常。
    - RuntimeException
    - 编译时异常

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/java-basic-exception-1.png)

- RuntimeException （运行时异常） 不可查异常（unchecked exceptions）
  - 如：NullPointerException（空指针）IndexOutOfBoundsException（越界）等
  - 这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由**程序逻辑错误引起的**，程序应该从逻辑角度尽可能避免这类异常的发生。
  - 特点：Java编译器不会检查，出现这种异常即使不被捕获也会编译通过。
- 编译异常  可查异常（checked exceptions）
  - 不处理此类异常编译就不会通过。
  - 需要用try-catch捕获，或者throws抛出。

### throw 和 thorws的区别

- throws: 异常的申明：
  - 若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。

```java
public static void method() throws IOException, FileNotFoundException{
    //something statements
}
```

- thorw: 异常抛出：

```java
public static double method(int value) {
    if(value == 0) {
        throw new ArithmeticException("参数不能为0"); //抛出一个运行时异常
    }
    return 5.0 / value;
}
```

### try-with-resource

- 资源实现了AutoCloseable接口的话，在try中打开的资源会在执行或异常后自动关闭。

```java
// 普通try catch
Scanner scanner = null;
try {
  scanner = new Scanner(new File("D://file.txt"));
  while (scanner.hasNext()) {
    // scanne.nextLine();
  }
} catch (FileNotFoundException e) {
  e.printStackTrace();
} finally {
  if (scanner != null) {
    scanner.close();
  }
}

// try with resource

try (Scanner scanner = new Scanner(new File("D:/file.txt"))) {
  while (scanner.hasNext()) {
    scanner.nextLine();
  }
} catch (FileNotFoundException e) {
  e.printStackTrace();
}

// 是用分号可以使用多个资源
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));
     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
    int b;
    while ((b = bin.read()) != -1) {
        bout.write(b);
    }
}
catch (IOException e) {
    e.printStackTrace();
}

```



### JVM的异常处理机制

- 异常表 

### 异常处理

1. 捕获异常

   将业务代码包裹在try块内部，当业务代码中发生任何异常时，系统都会为此异常创建一个**异常对象**。创建异常对象之后，JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。

2. 处理异常

   在catch块中处理异常时，应该先记录日志，便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况，进行相应的处理。比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。

3. 回收资源

   如果业务代码打开了某个资源，比如数据库连接、网络连接、磁盘文件等，则需要在这段业务代码执行完毕后关闭这项资源。并且，无论是否发生异常，都要尝试关闭这项资源。将关闭资源的代码写在finally块内，可以满足这种需求，即无论是否发生异常，finally块内的代码总会被执行。

### java异常机制

- try、catch、finally组成，当try中代码发生异常时，catch块捕获并处理某个异常、finally回收资源。

- 当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上通过throws关键字声明抛出异常，则该异常将交给JVM处理。

- 关于异常跟踪栈：

  程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息

### java异常接口

- Throwable是异常的顶层父类，代表所有的非正常情况。它有两个直接子类，分别是Error、Exception。
- Error是错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错误，因此应用程序不应该试图使用catch块来捕获Error对象。在定义方法时，也无须在其throws子句中声明该方法可能抛出Error及其任何子类。
- Exception是异常，它被分为两大类
  - Checked异常。不是RuntimeException类及其子类的异常实例则被称为Checked异常。Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。
  - Runtime异常。所有的RuntimeException类及其子类的实例被称为Runtime异常；Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try...catch块来实现。

## 反射

### 反射的使用方法：

```java
// 无论要获取变量还是方法，首先都要获取类对象
Class clazz = TestBean.class;
Class clazz = Class.forName("reflect.TestBean")// 此方法需要try catch
 
  TestBean bean = new TestBean("test", 25);
 	Class clazz = bean.getClass();
	
	Field fieldAge = clazz.getField("age"); // 直接通过变量名获取 public 变量
	
	Field fieldName = clazz.getDeclaredField("name");
	fieldName.setAccessible(true);
// 获取私有的变量。需要使用getDeclaredField且设置为true
	int age = fieldAge.getInt(bean);
	String name = (String) fieldAge.get(bean);
```

- 获取反射：

  - 首先需要获取反射对象
  - 通过反射类对象的实例，调用`getFiels()` 括号内为参数，获取反射类的成员变量。
  - 如果成员变量的权限是**私有**,2步骤的获取办法会抛异常,这时需要使用特工,也就是"**暴力反射**",调用getDeclaredField(" "),还需要让Field对象调用setAccessible(true)

  - 通过以上步骤可以获取到具体的字段的实例对象。然后使用`getXXX()`来获取值。括号里面的参数是反射所使用到的JavBean,也就是TestBean的实例

- 通过反射修改属性值

```java
fieldAge.set(bean, 12);
fieldName.set(bean, "test");
```

- 修改对象值
  - 参数1: 反射所使用到的JavBean, 也就是图片中的TestBean的实例 
  - 参数2: 我们自己想要设置修改的值,

- 获取方法数

```java
Class classMethod = bean.getClass();
Method[] methods = classMethod.getMethods();
```

- 获取类的方法并通过反射修改属性值

```java
// 类中包含方法 workCode(String person, String.class)，eat(int i) , study(String person,int i)

TestBean beanMethod = new TestBean("test", 22);
Class classMethod = beanMethod.getClass();
Method method1 = classMethod.getMethod("workCode", String.class);
method1.invoke(beanMethod, "xxxxx");

Method method2 = classMethod.getMethod("eat", int.class);
method2.invoke(beanMethod, 5);

Method method3 = classMethod.getMethod("study", String.class, int.class);
method3.invoke(beanMethod, "xxx", 5);
```

Java程序中的对象在运行时可以表现为两种类型，即编译时类型和运行时类型。例如 Person p = new Student(); ，这行代码将会生成一个p变量，该变量的编译时类型为Person，运行时类型为Student。

有时，程序在运行时接收到外部传入的一个对象，该对象的编译时类型是Object，但程序又需要调用该对象的运行时类型的方法。这就要求程序需要在运行时发现对象和类的真实信息，而解决这个问题有以下两种做法：

- 第一种做法是假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，可以先使用instanceof运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可。
- 第二种做法是编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。

具体来说，通过反射机制，我们可以实现如下的操作：

- 程序运行时，**可以通过反射获得任意一个类的Class对象**，并通过这个对象查看这个类的信息；
- 程序运行时，**可以通过反射创建任意一个类的实例**，并访问该实例的成员；
- 程序运行时，**可以通过反射机制生成一个类的动态代理类或动态代理对象。**

Java的反射机制在实际项目中应用广泛，常见的应用场景有：

- 使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；
- 多数框架都支持注解/XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；
- 面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现

### Constructor类及使用

- Constructor类的实例对象代表类的构造方法

```java
Class<?> class1 = Class.forName("com.xxx.reflect.test.Person");
  // 使用反射机制获得类的字节码文件对应的对象。
Person person1 = (Person) class1.newInstance();
// 直接调用这个类的newInstance()方法获得实例，默认调用无参构造
person1.xxx();

Constructor c = class1.getConstructor();
// 获得该类的无参构造方法。
Person person2 = (Person) c.newInstance();
// 直接通过无参构造获得对象的实例。相当于Person person = new Person();


Class<?> class2 = Class.forName("com.imooc.reflect.test.Person");
Constructor<?> c = class2.getConstructor(String.class, String.class);
Constructor<?>[] cs = class2.getConstructors();
Person person1 = (Person) cs[0].newInstance();
System.out.println(person1);
Person person2 = (Person) cs[1].newInstance("张三", "男");
System.out.println(person2);

Person person3 = (Person) c.newInstance("张三", "男");
System.out.println(person3);

// 获得有参构造方法
```

## SPI机制

### 什么是SPI机制

- Service Provider Interface 是JDK内置的一种 服务提供发现机制
- 其核心思想就是 **解耦**。SPI机制图：

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/java-advanced-spi-8.jpg)

- 应用：

JDBC接口定义

- java中定义了接口：`java.sql.Driver` 并没有具体实现，实现由数据库厂商提供。
- mysql实现
  - 在mysql的jar包`mysql-connector-java-6.0.6.jar`中，可以找到`META-INF/services`目录，该目录下会有一个名字为`java.sql.Driver`的文件，文件内容是`com.mysql.cj.jdbc.Driver`，这里面的内容就是针对Java中定义的接口的实现。
- postgresql实现
  - 同样在postgresql的jar包`postgresql-42.0.0.jar`中，也可以找到同样的配置文件，文件内容是`org.postgresql.Driver`，这是postgresql对Java的`java.sql.Driver`的实现。

使用：

```java
String url = "jdbc: xxxx://xxxx:xxxx/xxxx"
  Connection conn = DriverManager.getConnection(url, username, password);
// 不需要再使用Class.forName("com.mysql.jdbc.Driver")来加载驱动了
```

```java
// SPI简单示例
// 定义好接口
public interface Search {
  public List<String> searchDoc(String keyword);
}
// 实现
public class FileSearch implements Search {
  @Override
  public List<String> searchDoc(String keyword);
  return null;
}

// 数据库搜索实现
public class DatabaseSearch implements Search {
  @Override
  public List<String> searchDoe(String keyword) {
    sout("search");
    return null;
  }
}

// resource中
com.cainiao.ys.spi.learn.Search
 
public class TestCase {
    public static void main(String[] args) {
        ServiceLoader<Search> s = ServiceLoader.load(Search.class);
        Iterator<Search> iterator = s.iterator();
        while (iterator.hasNext()) {
           Search search =  iterator.next();
           search.searchDoc("hello world");
        }
    }
}
```



## java类

### clone方法

对于每一个类，需要确定：

1. 默认的clone能否满足要求
2. 是否可以在可变的子对象上调用clone来修补默认的clone方法
3. 是否不该使用clone

![image-20220416210421151](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220416210421151.png)

`.clone()`方法是`object`类中的方法。

- 浅拷贝：默认的克隆操作是浅拷贝
  - 如果被拷贝对象的所有字段都没有引用其他对象，则可以正常拷贝，但是一旦有引用其他对象，则拷贝后的对象仍然会与旧的对象有部分重合之处。
  - 如果原对象中的内容都是不可变的，那么这种共享就是安全的。如`String`

- 深拷贝：由于子对象通常都是可变的，因此必须重新定义clone方法来建立一个深拷贝
  - 同时克隆所有的子类对象。

注意⚠️：即使clone的默认（浅拷贝）能够满足要求，也要实现Cloneable接口，并将clone方法定义为public。

```java
class Employee implements Cloneable {
  public Employee clone() throws xxxException {
    return (Employee) super.clone();
  }
}
```

![image-20220416210622324](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220416210622324.png)

在同一个java源文件中，可以有多个class类，但是public的class只有一个

### 重写与重载

- 重载是同一个类中：多个方法的方法名相同、参数列表不同，则构成重载的关系。重载与方法的返回值以及访问修饰符无关，即重载的方法不能根据返回类型进行区分。
- 重写发生在父类子类中，若子类方法想要和父类方法构成重写关系，则它的方法名、参数列表必须与父类方法相同。另外，**返回值要小于等于父类方法，抛出的异常要小于等于父类方法，访问修饰符则要大于等于父类方法**。还有，**若父类方法的访问修饰符为private，则子类不能对其重写**。@override

- 构造方法不能重写。
  - 因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。

### 类优先原则

- 当一个实体继承了父类并且实现了多个接口时，接口中包含与父类同名的默认方法时，父类的方法会覆盖接口的方法。

```java 
interface interface1 {
  String getName() {System.out.println("interface1")};
}
interface interface2 {
  String getName() {System.out.println("interface2")};
}

public class named {
  public String getName() {
    return "named name";
  }
}
public class name extends named implements interface1, interface2 {
  // 父类方法覆盖接口方法
}
```

### 抽象类

- 抽象类体现一种模版设计。抽象类作为多个子类的抽象父类，是系统实现过程的中间产品。
- 抽象类中可以包含普通方法。
- 抽象类里则既可以定义普通成员变量，也可以定义静态常量。
- 抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
- 抽象类则完全可以包含初始化块。

> 接口中可以包含构造函数吗

由于接口定义的是一种规范，因此接口里**不能包含构造器和初始化块定义**。接口里可以包含**成员变量**（只能是**静态常量**）、**方法**（只能是**抽象实例方法**、类方法、默认方法或**私有方法**）、**内部类**（包括内部接口、枚举）定义。

> 接口与抽象类共同特征

- 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。
- 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。

> 面向接口编程

接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的**可扩展性和可维护性**。基于这种原则，很多软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，**希望通过面向接口编程来降低程序的耦合。**

### 内部类（ inner class）

- 内部类可以对同一个包中的其他的类隐藏
- 内部类中申明的所有静态字段都必须final，并初始化为一个编译时常量。
- 内部类不能有static方法。允许有静态方法，但是其职能访问外围类的静态字段和方法。
- 内部类拥有访问权限更高，可以访问外部类的私有属性和方法，对外部类传入`this`会报错。

![image-20220418210110255](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220418210110255.png)

#### 内部类加载

- 内部类加载与虚拟机无关，是一个编译器现象。编译器会将内部类加载为常规的class文件，用$分隔外部类名与内部类名，而对虚拟机是不可见的。

### 局部类

在方法中可以定义局部类，不能有public或private等申明。局部类作用域限定在申明这个局部类的块中。

局部类对外部世界完全隐藏。

### 匿名内部类

```java
new SuperType(construction params);
{
	inner class methods and data
}
```

`SuperType`可以是接口，内部类就要实现这个接口。

同时也可以是一个类，则要扩展这个类。

- 提供初始化对象。

```java
var friends = new ArrayList<String>();
friends.add("a");
friends.add("b");
invite(friends);

var friends = new ArrayList<String>() {{ add("a"); add("b"); }};
// 两层括号，外括号建立了ArrayList的匿名子类，内层括号则是一个对象初始化块。
```

### 静态内部类

![image-20220418211936988](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220418211936988.png)

- 为了防止重名，可以将内部类定义在ArrayAlg的一个公共内部类中

使用`ArrayAlg.Pair`来访问。

使用静态内部类不会生成它的外围类对象的引用。

**只要内部类不需要访问外围类对象，就应该使用静态内部类。**

### 服务加载器

- ServiceLoader类加载符合一个公共接口的服务。
- 初始化服务加载器：

```java
public static ServiceLoader<Cipher> cipherLoader = ServiceLoader.load(Cipher.class);
```

初始化工作只在程序中完成一次。

stream方法会生成ServiceLoader.Provider的一个流。

![image-20220418212928281](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220418212928281.png)



## Object类方法

- `Class<?> getClass() `返回该对象的运行时类。
- boolean equals(Object obj)：判断指定对象与该对象是否相等。
- int hashCode()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。
- String toString()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。
- Object类还提供了一个finalize()方法，当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。并且，针对某一个对象，垃圾回收器最多只会调用它的finalize()方法一次。
  - 注意，finalize()方法何时调用、是否调用都是不确定的，我们也不要主动调用finalize()方法。从JDK9开始，这个方法被标记为不推荐使用的方法。

### java.lang.Class

- `String getName() // 返回class name` 
- `Class getSuperclass() // 以Class对象形式返回这个类的超类`

### getClass()

### hash()

### toString()

- `Arrays.deepToString() // 打印多维数组`
- `String s = Arrays.toString()`

### equals()

- equals方法要求具有以下特性：
  - 自反性：对于任何非空饮用`x`,`x.equals(x)`返回应该为true；
  - 对称性：对于`x`和`y`当且仅当`y.equals(x)`为true时，`x.equals(y)`也为true；
  - 传递性：`x.equals(y)=true` `y.equals(z)=true` `x.equals(z)=true`；
  - 一致性：如果x和y饮用的对象没有发生变化，反复调用`x.equals(y)`结果应该相同。
  - 对于任意非`null`引用x，`x.equals(null)`应该为false；

```java
public boolean equals(Object otherObject) {
  // 比较this是否相等。
  if (this == otherObject) {
    return true;
  }
  // 检测是否为null
  if (otherObject == null) {
    return false;
  }
  // 比较this与otherObject的类是否一致
  if (getClass() != otherObject.getClass()) {
    return false;
  }
  // 如果所有子类都有相同语义
  if (!(otherObject instanceof ClassName)) {
    return false;
  }
  // 将Ohter对象强制转换为对应的变量。
  ClassName other = (ClassName) otherObject;
  return field1 == other.field1 && f2 == other.f2....;
}
```







## 接口

**接口中只有常量定义，没有变量声明。**

类中含有抽象方法，则该类必须为抽象类

- java继承

- java是单继承的，即一个子类智能有一个直接父类，但是可以有多个间接父类来实现“多继承”。

接口体现的是**规范**。对于接口实现，接口规定了必须向外提供哪些服务，对于调用者而言，接口规定了可以调用哪些服务，并且规定了调用的规范。

接口是**多个模块**之间的**耦合标准**；当在多个应用程序之间使用接口时，接口是**多个程序**之间的**通信标准**。

- 接口中只能有抽象方法、静态方法、默认方法和私有方法，不能提供实现。
- 接口里只能定义静态常量，不能定义普通成员变量；
- 接口里不包含构造器；
- 接口里不能包含初始化块；
- 一个类只能有一个直接父类（包括抽象类）但是可以实现多个接口。

# Java集合

![image-20220421214435212](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220421214435212.png)

## 集合类

#### LinkedList实现Queue()

- `offer()`与`add()` 都是在队尾添加一个元素
  - 一些队列有大小限制，如果想在一个满的队列中加入一个新项，多处的会被拒绝。
  - `add()`会抛出异常，而 `offer()`则是由其返回false
- `poll()`与`remove()` 都是从队头移除一个元素
  - 对于空列表，`remove()`会抛出异常，`poll()`会返回null。
- `peek()`获得队头元素不移除

### LinkedList实现Deque()栈

- `push()`进入栈顶
- `pop()`出栈
- `peek()`获得栈顶元素不移除

集合类主要由Collection和Map派生出。

Collection -> Set, List, Queue

Map

- Set代表无序的，元素不可重复的集合；

- List代表有序的，元素可以重复的集合；

- Queue代表先进先出（FIFO）的队列；

- Map代表具有映射关系（key-value）的集合。

  ![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/74C2C3389688C6364FF2DE8AA768A039.jpeg)

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/E26BABF74692B006DA33C112A6FD5EEC.jpeg)



- 线程不安全集合：性能好
  - HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap

- 如果需要使用线程安全的集合类，则可以使用Collections工具类提供的synchronizedXxx()方法，将这些集合类包装成线程安全的集合类。

从Java5开始，Java在java.util.concurrent包下提供了大量支持高效并发访问的集合类，它们既能包装良好的访问性能，有能包装线程安全。这些集合类可以分为两部分，它们的特征如下：

- 以Concurrent开头的集合类：

  以Concurrent开头的集合类代表了支持并发访问的集合，它们可以支持多个线程并发写入访问，这些写入线程的所有操作都是线程安全的，但读取操作不必锁定。以Concurrent开头的集合类采用了更复杂的算法来保证永远不会锁住整个集合，因此在并发写入时有较好的性能。

- 以CopyOnWrite开头的集合类：

  以CopyOnWrite开头的集合类采用复制底层数组的方式来实现写操作。当线程对此类集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对此类集合执行写入操作时，集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。

### Map接口的实现类

HashMap、 LinkedHashMap、TreeMap、ConcurrentHashMap。

- 对于不需要排序的场景，优先考虑使用HashMap，因为它是性能最好的Map实现。
- 如果需要保证线程安全，则可以使用ConcurrentHashMap。它的性能好于Hashtable，如果需要保证线程安全，则可以使用ConcurrentHashMap。它的性能好于Hashtable，

#### LinkedHashMap

```java
LinkedHashMap<K, V> cache = new LinkedHashMap<K, V>(128, 0.75F, true)
{
  	protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
      return size() > 100;
    }
}
```



#### Map .put过程

1. 判断数组是否为空，若数组为空则进行第一次扩容（resize）
2. 通过hash算法，计算键值对在数组中的索引
3. 插入数据
   - 如果当前位置元素为空，则直接插入数据；
   - 如果当前位置元素非空，且key已存在，则直接覆盖其value；
   - 如果当前位置元素非空，且key不存在，则将数据链到链表末端；
   - 若链表长度达到8，则将链表转换成红黑树，并将数据插入树中；
4. 再次扩容
   - 如果数组中元素个数（size）超过threshold，则再次进行扩容操作。

### 得到一个线程安全的map

- 不建议使用Hashtable，虽然Hashtable是线程安全的，但是性能较差。
- 使用Collections工具类，将线程不安全的Map包装成线程安全的Map；
- 使用java.util.concurrent包下的Map，如ConcurrentHashMap；

#### ConcurrentHashMap

jdk1.7：底层是HashEntry数组，使用分段锁：Segment，将Hash数组分为多个Segment段，每次对某个段加锁。

jdk1.8：底层使用Node数组，红黑树使用TreeNode（当Node链表长度超过8的时候转为红黑树）。放弃了Segment设计，仅在hash冲突的时候加锁，效率提升。

#### hashmap

hashmap线程不安全

hashmap可以使用null作为key或value

#### JDK7和JDK8中的HashMap有什么区别？

JDK7中的HashMap，是基于数组+链表来实现的，它的底层维护一个Entry数组。它会根据计算的hashCode将对应的KV键值对存储到该数组中，一旦发生hashCode冲突，那么就会将该KV键值对放到对应的已有元素的后面， 此时便形成了一个链表式的存储结构。

JDK7中HashMap的实现方案有一个明显的缺点，即当Hash冲突严重时，在桶上形成的链表会变得越来越长，这样在查询时的效率就会越来越低，其时间复杂度为O(N)。

JDK8中的HashMap，是基于**数组+链表+红黑树**来实现的，它的底层维护一个Node数组。当链表的存储的数据个数大于等于8的时候，不再采用链表存储，而采用了红黑树存储结构。这么做主要是在查询的时间复杂度上进行优化，链表为O(N)，而红黑树一直是O(logN)，可以大大的提高查找性能。

#### hashmap底层实现原理

- 当使用(key,value)调用put方法时，会调用HashCode计算hash值从而得到bucket位置，进行存储。
- hashmap会根据当前bucket的占用情况自动调整容量（如果超过Load Facotr，则resize为2倍）。
- 获取对象时，将key传给get，调用hashcode计算，并进一步调用equals()方法确定值。
- 发生hash碰撞时，通过链表将碰撞元素组织起来。java8以后，如果碰撞元素超过限制（默认8个），则使用红黑树来替换链表，提高速度。链表的时间复杂度时O(N)，红黑树为O(log n)

#### hashmap扩容机制

- 初始容量为16，容量以2的次方扩充，使用位运算代替取模运算。
- 数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。
- 为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。
- 对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。

- 在扩充hashmap的时候不需要重新计算hash值，只需要看原来的hash值新增的bit是0还是1
  - 0则索引不变，为1的话，变成“原索引+oldCap”。

#### hashmap死循环链表产生（hashmap线程不安全的原因）

在**多线程**的情况下，当**重新调整HashMap大小的时候**，就会存在**条件竞争**，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历。如果条件竞争发生了，那么就会产生死循环了。

#### 如何实现线程安全

- 直接使用Hashtable类
- 直接使用ConcurrentHashMap
- 使用Collections将HashMap包装为线程安全的类

#### 红黑树不用B/B+树

- B/B+树多用于外存上，对磁盘友好。
- HashMap本来是数组+链表的形式，链表由于其查找慢的特点，所以需要被查找效率更高的树结构来替换。如果用B/B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面，这个时候遍历效率就退化成了链表。

#### treemap

- TreeMap基于红黑树（Red-Black tree）实现。映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。
- TreeMap的基本操作containsKey、get、put、remove方法，它的时间复杂度是log(N)。

### WeakHashMap

- **弱引用**的hashmap，通过弱引用来管理entry。可以不用调用remove()或clear()就会被GC自动删除。
- 当引用仅剩来自散列的映射时，会被自动垃圾回收

***WeakHashMap\* 的这个特点特别适用于需要缓存的场景**。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。

### Iterator 迭代器

![image-20220421213443060](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220421213443060.png)

for each循环可以处理任何实现了Iterable接口的对象。

`iterator.forEachRemaining(element -> do something); `

### ArrayList和Vector

#### ArrayList扩容机制

- 初始化构造函数：
  - 无参构造构造一个空列表

Vector效率低，但是线程安全。

#### ArrayList加入大量元素

- 先调用`ensureCapacity()`方法，申请内存，减少反复扩容的次数。


#### unmodifiableList

- `Collections`的方法，将返回一个实现List借口的类对象。并使代码查看（但不能修改）一个集合的内容：

```java
LinkedList<String> strings = new LinkedList<>();
Collections.unmodifiableList(strings);
```

#### synchronizedMap

```java
var map = Collections.synchronizedMap(new HashMap<String, Employee>()) 
  // 能够将其转换成线程安全的类
```

#### 检查型视图

```java
List<String> safeStrings = Collections.checkedList(strings, String.class);
ArrayList rawList = safeStrings;
rawList.add(new Date()) // thorws a ClassCastException
```

#### Collections.shuffle

- 随机打乱列表中的元素

## List和Set

### 方法

- 队列： Queue(单向队列)

```java
add(E):boolean 在队尾添加元素，添加成功返回true，如果队列已满无法添加则抛出异常。
offer(E):boolean 在队尾添加元素，添加成功返回true，如果队列已满无法添加则返回false。
remove():E 删除队头元素，并返回删除的元素，如果队列为null，抛出异常。
poll():E 删除队头元素，并返回删除的元素，如果队列为null，返回null。
element():E 获取队头元素，如果队列为null将抛出异常。
peek():E 获取队头元素，如果队列为null将返回null。
```

- Deque（双向队列）

```java
Deque<Integer> deque = new LinkedList<>();
 
addFirst(E):void 在队头添加元素。
addLast(E):void 在队尾添加元素。
offerFirst(E):boolean 在队头添加元素，并返回是否添加成功。
offerLast(E):boolean 在队尾添加元素，并返回是否添加成功。
removeFirst():E 删除队头元素，并返回删除的元素，如果队列为null，抛出异常。
removeLast():E 删除队尾元素，并返回删除的元素，如果队列为null，抛出异常。
pollFirst():E 删除队头元素，并返回删除的元素，如果队列为null，返回null。
pollLast():E 删除队尾元素，并返回删除的元素，如果队列为null，返回null。
getFirst():E 获取队头元素，如果队列为null将抛出异常。
getLast():E 获取队尾元素，如果队列为null将抛出异常。
peekFirst():E 获取队头元素，如果队列为null将返回null。
peekLast():E 获取队尾元素，如果队列为null将返回null。
removeFirstOccurrence(Object):boolean 删除第一次出现的指定元素，并返回是否删除成功。
removeFirstOccurrence(Object):boolean 删除最后一次出现的指定元素，并返回是否删除成功。
```

- 栈 Stack

```java
peek():E 获取队头元素，如果队列为null将返回null。
push(E):void 栈顶添加一个元素。
pop():E 移除栈顶元素，返回移除的元素，如果栈没有元素抛出异常。
```

- LinkedList:双向链表 实现了Deque接口。

```java
创建方式：（可以实现双向链表和双端队列）
    LinkedList list = new LinkedList(); //双向链表的创建
    Deque<Integer> deque = new LinkedList<>(); //双端队列的创建
队列方法：
list.add("A");  
list.add("B");  
list.add("C");  
list.add("D");  
list.addFirst("X");  //在头部添加元素
list.addLast("Z");  
System.out.println(list);  
list.removeFirst();  //移除元素
list.removeLast(); 
list.getFirst();  //获取元素
list.getLast(); 
list.isEmpty();
```



### Stack、ArrayDeque、LinkedList

- 未知的初始数据量：LinkedList
- 频繁的随机访问操作：ArrayDeque
- 频繁的插入、删除操作：LinkedList
- 线程安全：
  - Stack -- 同步
  - ArrayDeque -- 不同步
  - LinkedList -- 不同步

### ArrayList和LinkedList

ArrayList的实现是基于**数组**，LinkedList的实现是基于**双向链表**；

1. 对于随机访问ArrayList要优于LinkedList，ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问，而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起，查找某个元素的时间复杂度是O(N)；
2. 插入操作时，LinkedList不需要重新计算大小或更新索引。
3. LinkedList更占内存，除了存储数据以外，还存储了两个引用（双向链表）

- ArrayList自动扩容
  - 数组扩容通过ensureCapacity(int minCapacity)方法来实现。如果需要添加大量元素之前，可以手动使用这个方法来手动增加容量。
  - 每次数组容量的增长大约是其原容量的1.5倍，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中。

### ArrayList的Fail-Fast机制

- ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。

###  有哪些线程安全的List？

1. Vector

   Vector是比较古老的API，虽然保证了线程安全，但是由于效率低一般不建议使用。

2. **Collections.SynchronizedList**

SynchronizedList是Collections的内部类，Collections提供了synchronizedList方法，可以将一个线程不安全的List包装成线程安全的List，即SynchronizedList。它比Vector有更好的扩展性和兼容性，但是它所有的方法都带有同步锁，**也不是性能最优的List。**

3. **CopyOnWriteArrayList**

CopyOnWriteArrayList是Java 1.5在java.util.concurrent包下增加的类，它采用复制底层数组的方式来实现写操作。当线程对此类集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对此类集合执行写入操作时，集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。在所有线程安全的List中**，它是性能最优的方案。**

- 并发类，读操作无锁的ArrayList。在写操作时会复制新的List，在新的List上完成写操作，保证线程安全。



- 优点：读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。在遍历传统的List时，若中途有别的线程对其进行修改，则会抛出ConcurrentModificationException异常。而CopyOnWriteArrayList由于其"读写分离"的思想，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了。
- 缺点：一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC。二是无法保证实时性，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。

### TreeSet和HashSet

HashSet、TreeSet中的元素都是不能重复的，并且它们都是线程不安全的，二者的区别是

1. HashSet中的元素可以是null，但TreeSet中的元素不能是null；
2. HashSet不能保证元素的排列顺序，而TreeSet支持自然排序、定制排序两种排序的方式；
3. HashSet底层是采用哈希表实现的，而TreeSet底层是采用红黑树实现的。

- HashSet基于HashMap实现，初始容量16，负载因子0.75的HashMap。放入HashSet中的值实际上是用HashMap的key来保存，Value存储一个PRESENT，为静态Object对象。

### ArrayList

ArrayList的底层是用**数组**来实现的，默认第一次插入元素时创建**大小为10的数组**，超出限制时会增加50%的容量，并且数据以 **System.arraycopy()** 复制到新的数组，因此最好能给出数组大小的预估值。

数组下标访问，时间复杂度O(1);

直接在数组末尾加入元素的性能也高，但如果按下标插入、删除元素，则要用 System.arraycopy() 来移动部分受影响的元素，性能就变差了，这是基本劣势。

### BlockingQueue（阻塞队列）

- 解决了多线程中，高效安全传输数据的问题。
- 放入数据
  - offer(anObject):
  - 表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）
  - offer(E o, long timeout, TimeUnit unit) 可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。
  - put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.
- 获取数据
  - poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;
  - poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。
  - take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入; 
  - drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。

### ArrayList方法

```java
ArrayList<Object> arr = new ArrayList<>();
arr.ensureCapacity(100); // 分配一个包含100个对象的内部数组

ArrayList<Object> arr = new ArrayList<>(100);

// 一旦确认不会再向数组列表添加任何元素时调用
arr.trimToSize() // 会调整数组大小为当前大小，gc会回收多余内存
```

![image-20220412202128033](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220412202128033.png)

# Java并发

## 线程池

### ThreadPoolTaskExecutor



## 多线程

### 线程的状态

- New（新建）
- Runnable(可运行)
- Blocked（阻塞）
- Waiting（等待）
- Timed waiting（即使等待）
- Terminated（终止）

`Thread.yield() //使当前正在执行的线程向另一个线程交出运行权 static `

### 守护线程

```java
t.setDeamon(true);
```

守护线程会在后台为其他线程提供服务，如：计时器线程

### CAS无锁机制

![image-20220421153949680](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220421153949680.png)

- 线程从主内存中拷贝一份数据到工作内存中，然后操作工作内存。
- CAS的工作是：在线程从主内存中拉了一个副本过来，并完成计算后，在写回的时候，先比较拉下来的副本的原始值与主内存中的是否一致，如果一致，则通过原子操作些过去，如果不一致则重新拉取副本再次执行。

### 乐观锁与悲观锁

- 这两种锁出现在数据库中。

- 悲观锁：

  - 悲观锁表示对于每次修改，都会悲观的认为该操作是不安全的，会被修改，因此会在每次修改的时候对操作上锁：

    ```sql
    select * from * for update...
    ```

  - 适用于写操作更多的时候

- 乐观锁：

  - 乐观的认为每次操作都不会被修改，因此不上锁，但是会为数据增加一个版本号：version，并在读取的时候获取version，写入的时候再次读取version并对比是否一致，若一致则写入，若不一致则失效。

- 这两种锁的使用场景不一样。悲观锁在修改操作更多的时候使用，乐观锁则是修改操作较少的时候使用。

### 概念

### 实现线程安全

- 不要跨线程共享变量
- 使状态变量不可变
- 在任何访问状态变量的时候同步

无状态对象永远是线程安全的

#### 原子性

- synchronized和Lock
  - 能够保证任意时刻只有一个线程执行该代码块。

```java
// 原子性的自增自减
long id = nextNumber.incrementAndGet();
nextNumber.decrementAndGet();
```



### 内置锁

#### 可见性

- volatile
  - 不能替代synchronized，无法保证操作的原子性
  - 变量被修饰时，他会保证修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值。
- 通过synchronized和Lock也能够保证可见性

#### 有序性

- happens-before原则（先行发生原则）：

### 创建线程的方式

1. 继承Thread类
   - 定义Thread类的子类，重写run()方法，run()方法将作为线程执行体。
   - 创建Thread子类的实例，即创建线程对象。
   - 调用Thread的start()方法来启动该线程。

2. 实现Runnable接口来创建并启动线程
   - 定义Runnable接口的实现类，并实现该接口的run()方法，该run()方法将作为线程执行体。
   - 创建Runnable实现类的实例，并将其作为Thread的target来创建Thread对象，Thread对象为线程对象。
   - 调用线程对象的start()方法来启动该线程。

3. 通过实现Callable接口来创建并启动线程的步骤如下：
   - 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，且该call()方法有返回值。然后再创建Callable实现类的实例。
   - 使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
   - 使用FutureTask对象作为Thread对象的target创建并启动新线程。
   - 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

- 实现Runnable接口与实现Callable接口的方式基本相同，Callable接口里定义的方法有返回值，可以申明抛出异常。
- 采用实现Runnable、Callable接口的方式创建多线程的优缺点：
  - 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。
  - 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
  - 劣势是，编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread()方法。

- 采用继承Thread类的方式创建多线程的优缺点：
  - 劣势是，因为线程类已经继承了Thread类，所以不能再继承其他父类。
  - 优势是，编写简单，如果需要访问当前线程，则无须使用Thread.currentThread()方法，直接使用this即可获得当前线程。

鉴于上面分析，因此一般推荐采用实现Runnable接口、Callable接口的方式来创建多线程。

Thread类的常用方法：

```java
	// 构造方法
	Thread()
	Thread(String name) 
    // name 为线程名 target为包含线程体的目标对象。
 	Thread(Runnable target)
  Thread(Runnable target, String name)

   // 静态方法
   currendThread() // 返回当前正在执行的线程
   interrupted() // 返回当前执行的线程是否已经被中断
   sleep(long millis) // 使当前执行的线程睡眠多少毫秒数
   yield() // 使当前执行的线程自愿暂时放弃对处理器的使用权并允许其他线程执行；
    
    // Thread类常用实例方法：

		getId() // 返回该线程的id

  	getName() // 返回该线程的名字

		getPriority() //返回该线程的优先级

    interrupt() // 使该线程中断；

    isInterrupted() // 返回该线程是否被中断；

    isAlive() // 返回该线程是否处于活动状态；

    isDaemon() // 返回该线程是否是守护线程；

    setDaemon(boolean on) // 将该线程标记为守护线程或用户线程，如果不标记默认是非守护线程；

    setName(String name) // 设置该线程的名字；

    setPriority(int newPriority) // 改变该线程的优先级；

    join() // 等待该线程终止；

    join(long millis) // 等待该线程终止,至多等待多少毫秒数。
```

###  run()和start()的区别？

- run()方法为线程执行体，该方法代表线程需要执行的任务
- Start()方法用来启动线程。

start方法真正实现多线程运行，run方法只是在当前线程中执行run方法，并没有达到写线程的目的。

```java
TestThread thread = new TestThread();

Thread thread = new Thread(thread);
thread.start();
```

当使用new关键字创建 了一个线程之后，并不会立即运行，仅仅由java虚拟机为其分配了内存，并初始化成员变量的值。

当该对象调用start()方法以后，该线程处于就绪状态，java虚拟机会为其创建方法调用栈和程序计数器。

至于该线程何时开始运行，取决于JVM里线程调度器的调度。

### 线程的生命周期

- 新建（new）

  - 使用new关键字创建线程后。

- 就绪（ready）

  - 调用start()后处于就绪状态。

- 运行（running）

  - 获得CPU后，开始执行run()方法体。
  - 则该线程处于运行状态，如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。

- 阻塞（Blocked）

  - 线程调用sleep()方法主动放弃所占用的处理器资源。
  - 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。
  - 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。
  - 线程在等待某个通知（notify）。
  - 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。

  - 针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态：
    - 调用sleep()方法的线程经过了指定时间。
    - 线程调用的阻塞式IO方法已经返回。
    - 线程成功地获得了试图取得的同步监视器。
    - 线程正在等待某个通知时，其他线程发出了一个通知。
    - 处于挂起状态的线程被调用了resume()恢复方法。

- 死亡（dead）
  - run()或call()方法执行完成，线程正常结束。
  - 线程抛出一个未捕获的Exception或Error。
  - 直接调用该线程的stop()方法来结束该线程，该方法容易导致死锁，**通常不推荐使用**。

### 实现线程同步

- synchronized关键词修饰方法，内置锁会保护整个方法。调用前需要获得内置锁，否则就处于阻塞状态。
  - 可以修饰静态方法，此时如果调用静态方法，将会锁住整个类。

- 同步代码块
  - 即有synchronized关键字修饰的语句块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。需值得注意的是，同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。
- ReentrantLock
  - ReentrantLock类是可重入、互斥、实现了Lock接口的锁
  - 它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力。
  - ReentrantLock还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，因此不推荐使用。
- volatile
  - volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值。需要注意的是，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。
- 原子变量
  - 在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。例如AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中（如以原子方式增加的计数器），但不能用于替换Integer。可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。

### Java多线程之间的通信方式

- wait()、notify()、notifyAll()
  - 如果线程间使用synchronized来保证线程安全，可以使用这三个方法实现线程通信。
  - wait()方法可以让当前线程释放对象锁并进入阻塞状态
  - notify()方法用于唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。
  - notifyAll()用于唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。

每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了已就绪（将要竞争锁）的线程，阻塞队列存储了被阻塞的线程。当一个阻塞线程被唤醒后，才会进入就绪队列，进而等待CPU的调度。反之，当一个线程被wait后，就会进入阻塞队列，等待被唤醒。

- await()、signal()、signalAll()
  - 如果线程之间采用Lock来保证线程安全，则可以利用await()、signal()、signalAll()来实现线程通信。
  - Condition接口中的方法(条件线程)
  - 该接口是在Java 1.5中出现的，它用来替代传统的wait+notify实现线程间的协作
  - 相比使用wait+notify，使用Condition的await+signal这种方式能够更加安全和高效地实现线程间协作。
  - Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() 
    - 必须要注意的是，Condition 的 await()/signal()/signalAll() 使用都必须在lock保护之内
    - 也就是说，必须在lock.lock()和lock.unlock之间才可以使用
    - 事实上，await()/signal()/signalAll() 与 wait()/notify()/notifyAll()有着天然的对应关系。
    - 即：Conditon中的await()对应Object的wait()，Condition中的signal()对应Object的notify()，Condition中的signalAll()对应Object的notifyAll()。
  - BlockingQueue
    - 阻塞队列。
    - 程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。线程之间需要通信，最经典的场景就是**生产者与消费者**模型，而BlockingQueue就是针对该模型提供的解决方案。
  - 一个线程被wait()后会进入阻塞队列，阻塞队列存储了被阻塞的线程。当阻塞线程被唤醒 notify()/ notifyAll()后，会唤醒进入就绪队列，以便在当前线程释放锁后竞争锁，得到CPU的执行。

### sleep() 和 wait()

- Sleep()是Thread类的静态方法，wait()是Object中的成员方法。
- Sleep()可以在任何地方使用，wait()只能在同步方法或代码块中使用。
- Sieep()不会释放锁，wait()会释放锁，并通过notify() / notifyAll()重新获取锁。

### notify() 与 notifyAll()

- notify()

  用于唤醒**一个**正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。

- notifyAll()

  用于**唤醒所有**正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。

# JavaIO

## IO流

字节流适合读取一些图片等字节数据，字符流适合处理汉字等字符数据

IO（Input Output）实现对数据的输入输出操作。

- 按数据流向：输入流和输出流。
- 按照数据类型，可以将流分为字节流和字符流，其中字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符
- 按照处理功能，可以将流分为节点流和处理流，其中节点流可以直接从/向一个特定的IO设备（磁盘、网络等）读/写数据，也称为低级流，而处理流是对节点流的连接或封装，用于简化数据读/写功能或提高效率，也称为高级流

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/3813D6FF51EAD282F3995515D9A61541.png)

### 使用流打开大文件

打开大文件，应避免直接将文件中的数据全部读取到内存中，可以采用分次读取的方式。

1. 使用缓冲流。缓冲流内部维护了一个缓冲区，通过与缓冲区的交互，减少与设备的交互次数。使用缓冲输入流时，它每次会读取一批数据将缓冲区填满，每次调用读取方法并不是直接从设备取值，而是从缓冲区取值，当缓冲区为空时，它会再一次读取数据，将缓冲区填满。使用缓冲输出流时，每次调用写入方法并不是直接写入到设备，而是写入缓冲区，当缓冲区填满时它会自动刷入设备。
2. 使用NIO。NIO采用内存映射文件的方式来处理输入/输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了（这种方式模拟了操作系统上的虚拟内存的概念），通过这种方式来进行输入/输出比传统的输入/输出要快得多。

### 字节流和字符流

字节流用来读取图片和视频等

读取字符等信息建议使用字符流防止乱码

### NIO的实现原理

- 组成：Channel、Buffer、Selector
- Channel：
  - 所有的IO从Channel开始，数据从Channel中读取到buffer中。
  - 其中比较常用的有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等，这些通道涵盖了UDP和TCP网络IO以及文件IO。
- Buffer是一块可以写入数据、读取数据的内存。被包装为NIO Buffer对象，提供了一组方法，用来方便的访问该块的内存。
  - Buffer对象包含三个属性：capacity、position、limit。
    - 读模式：
      - capacity表示最大容量
      - position表示当前读取的位置
      - limit表示能够最大读取到数据的位置
    - 写模式：
      - capacity一致
      - position表示当前写入的位置，初始值为0，最大可到capacity - 1的位置
      - limit表示最大能写多少数据， limit = capacity
- Selector
  - selector能够允许单线程处理多个channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件例如有新连接进来，数据接收等。

### 序列化工具

- JSON：目前使用比较频繁的格式化数据工具，简单直观，可读性好，有jackson，gson，fastjson等等，比较优秀的JSON解析工具的表现还是比较好的，有些json解析工具甚至速度超过了一些二进制的序列化方式。
- Protobuf：一个用来序列化结构化数据的技术，支持多种语言诸如C++、Java以及Python语言，可以使用该技术来持久化数据或者序列化成网络传输的数据。相比较一些其他的XML技术而言，该技术的一个明显特点就是更加节省空间（以二进制流存储）、速度更快以及更加灵活。另外Protobuf支持的数据类型相对较少，不支持常量类型。由于其设计的理念是纯粹的展现层协议（Presentation Layer），目前并没有一个专门支持Protobuf的RPC框架。
- Thrift：是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。 但是，Thrift并不仅仅是序列化协议，而是一个RPC框架。 相对于JSON和XML而言，Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案。但是由于Thrift的序列化被嵌入到Thrift框架里面， Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用（例如HTTP）。
- Avro：提供两种序列化格式，即JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美， JSON格式方便测试阶段的调试。 Avro支持的数据类型非常丰富，包括C++语言里面的union类型。Avro支持JSON格式的IDL和类似于Thrift和Protobuf的IDL（实验阶段），这两者之间可以互转。Schema可以在传输数据的同时发送，加上JSON的自我描述属性，这使得Avro非常适合动态类型语言。 Avro在做文件持久化的时候，一般会和Schema一起存储，所以Avro序列化文件自身具有自我描述属性，所以非常适合于做Hive、Pig和MapReduce的持久化数据格式。对于不同版本的Schema，在进行RPC调用的时候，服务端和客户端可以在握手阶段对Schema进行互相确认，大大提高了最终的数据解析速度。

#### 如果不用JSON工具，该如何实现对实体类的序列化？

可以使用Java原生的序列化机制，但是效率比较低一些，适合小项目；

可以使用其他的一些第三方类库，比如Protobuf、Thrift、Avro等。

## java读写文件

- 使用的是java.io.OutputStream和InputStream
- File类能够存储文件属性，能够建立文件，能够获取文件的目录信息

# JVM虚拟机

## 对象创建

- TLAB（Thread Local Allocation Buffer) ，根据线程在堆中分配内存，哪个线程需要分配对象内存，则在哪块区域中进行分配。是否使用TLAB参数：`-XX:+/-UseTLAB`
- CAS配合失败重试的方式保证更新操作的原子性。

## JVM启动流程

1. 最初启动类
2. 选择JRE版本
3. 创建JVM执行环境
4. 加载JVM
5. 初始化JVM
6. 新建线程ContinueInNewThread
7. ContinueInNewThread0
8. JavaMain （开始执行java程序）
9. 初始化虚拟机
10. 加载主类
11. GetApplicationClass
12. POSTJVMInit
13. GetStaticMethodID
14. 执行主方法
15. LEAVE结束

## JNI调用本地方法

- JNI（Java Native Interface） java本地接口

## JVM内存管理

### 内存划分：

- （线程独有） 程序计数器：保存当前程序的执行位置。
- （线程独有）虚拟机栈：通过栈帧来维持方法的调用顺序，帮助控制程序运行。
- （线程独有）本地方法栈：同上，作用于本地方法。
- 堆：所有的对象和数组都保存在这里
- 方法区：类信息、即时编译器的代码缓存、运行时常量池。

![image-20220317211723773](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211723773.png)

- 线程私有
  - 程序计数器
  - 虚拟机栈（JAVA编译-> class文件）
    - 每个方法被执行时，java虚拟机会同步创建一个栈帧
    - **栈帧**->局部变量表、操作数栈、动态链接（链接方法）、方法出口、运行时常量池。(每个方法产生一个栈帧)
    - Invoke static动态链接方法，栈帧入栈。

![image-20220317211717589](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211717589.png)

- 执行完成后出栈。
- 本地方法栈（为本地方法准备）

### off-heap

- off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集。序列化和反序列化将会影响部分性能（所以可以考虑使用FST-serialization）使用堆外内存能够降低GC导致的暂停。堆外内存不受垃圾收集器管理，也不属于老年代，新生代。

### 堆

- 共享区域（虚拟机中最大的一块内存，存放和管理对象和数组）

- 方法区：用于存储所有的类信息、常量、静态变量、动态编译缓存等数据。

  ![image-20220317211659460](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211659460.png)

- 创建对象->放入堆中

- .intern()方法可以从常量池中是否包含，返回常量池的地址

![image-20220317211628157](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211628157.png)

![image-20220317211621904](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211621904.png)

```java
	// jdk1.7前的操作
```

![image-20220315201958577](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220315201958577.png)

```java
public static void main(String[] args) {
  String str1 = new String("ab") + new String("c");
  String str2 = new String("ab") + new String("c");
  
  sout(str1 == str1.intern()); // true
  sout(str2.intern() == str1); // true
```

## 内存溢出、栈溢出

- OutOfMemoryError

### 申请堆外内存

- Unsafe类（通过反射调取）

```java
Field unsafeField = Unsafe.class.getDeclaredFields()[0];
unsafeField.setAccessible(true);
Unsafe unsafe = (Unsafe) unsafeField.get(null);

//申请4字节的内存病得到地址
long address = unsafe.allocateMemory(4);
//在地址上设定值
unsafe.putInt(address, 666);
sout(unsafe.getInt(address));

unsafe.freeMemory(address);
```

nio框架使用堆外内存提升效率

### java对象尽量不要在循环中创建

```java
// 正确的创建方法
Object obj = null;
for (int i = 0; i < 10000; ++i) {
  obj = new Object();
  System.out.println("obj= " + obj);
}
```

- 此方法仅在内存中保存一份对该对象的引用。减少内存空间浪费，增大垃圾回收的负荷。

- 对象具备下列特征：

  - 系统至少维护着对象的一个强引用（Strong Reference）
  - 所有对该对象的引用全部是强引用（除非显式的用了：软引用（Soft Reference）、弱引用（Weak Reference）或虚引用（Phantom Reference））

  

```java
import java.lang.ref.SoftReference;

A a = new A();

// 使用 a

// 使用完成后，设置为soft引用类型，并释放强引用
SoftReference sr = new SoftReference(a);
a = null;

//下次使用时
if (sr != null) {
  a = sr.get();
} else {
  // GC由于内存不足会回收软引用，需要重新装载
  a = new A();
  sr = new SoftReference(a);
}
```

 https://blog.csdn.net/yanliguoyifang/article/details/80964237

- java对象终结阶段（虚拟机直接回收该对象）
  - 垃圾回收器发现该对象已经不可到达
  - finalize方法已经被执行
  - 对象空间已被重用

## 垃圾回收


### 判定是否可被回收

- 引用计数法
  - 每个对象都包含一个引用计数器，用于存放引用计数（存放引用次数）
  - 每当一个地方引用时，引用次数+1
  - 引用失效（离开局部变量作用域，或被设定为null）引用计数-1
  - 引用计数 = 0时，表示不再被使用，因此没有方法可以得到此对象引用了

### 可达性分析算法

类似于树结构的搜索机制

- 每个对象的引用有机会成为根节点

![image-20220317211603333](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211603333.png)

![image-20220317211558132](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211558132.png)

如果某对象没有路径到达GCroots时，则证明此对象不会再被使用，可以被回收。

### 最终判定 finalize() 方法

 Object类 finalize() 方法。子类重写此方法，则在回收时进行二次确认。

![image-20220317211550623](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211550623.png)

使用此方法来销毁同时创建的资源。（虚拟机自动建立的一个优先级较低的线程）

Finalize()方法每个对象只能生效一次。第二次满足回收条件时必被回收

![image-20220317211543805](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211543805.png)

- java虚拟机将堆内存划分为**新生代**、**老年代**和永久代

![image-20220317211537702](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211537702.png)

- 运作：
  - 创建对象一开始进入新生代Eden区，大对象直接丢进老年代
  - 在新生代区域的垃圾回收堆新生代区域扫描，并回收不使用的对象。
  - 在一次垃圾回收以后，Eden区没有被回收的对象进入Survivor区。在开始时from和to都是空的，而GC后，所有Eden存活的对象进入From区，最后From和To发生交换，
  - 在存活对象进入到From区后，对To区对象年龄判定（每经历一轮GC年龄+1，对象年龄大于15 则进入老年代。否则进入From区。
- 新生代
  - Eden空间
  - Survivor
    - From
    - To
- 老年代
  - GC频率相对较低
  - 常用对象

#### 垃圾收集：

- Minor GC - 次要垃圾回收，对新生代区域的垃圾回收
  - 新生代Eden区容量已满时
- MajorGC - 主要垃圾回收，回收老年代垃圾
- Full GC - 完全垃圾回收
  - 对整个堆内存和方法区进行回收
    - 触发条件1：每次晋升到老年代的对象平均大小大于老年代剩余空间
    - 2: Minor GC后存活对象超过老年代剩余空间
    - 3 ： 永久代内存不足（jdk8以前
    - 4：手动调用System.gc()

#### 空间分配担保

- 在一次GC后，新生代Eden区仍然存在大量对象（超过Survivor区容量）
  - 可以把Survivor区无法容纳的对象直接送到老年代，让老年代进行分配担保。
  - 当新生代无法容纳时，丢到老年代。
  - 判断每次垃圾回收进入老年代的平均大小是否小于当前老年代剩余空间，如果小于，那说明也许放得下，否则会先来一次Full GC，大规模垃圾回收来尝试空间。还放不下就OOM

![image-20220317211528349](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211528349.png)

### 具体的垃圾收集过程

#### 标记-清除算法

- 首先标记出所有的需要回收的对象，然后依次回收掉被标记的对象。

缺点：

1. 如果内存中存在大量对象，可能会存在大量标记，并且大规模清除
2. 清除之后，连续的空间会有许多空隙，碎片化导致连续内存空间利用率降低

#### 标记-复制算法（适用于新生代，不适合老年代）

- 将容量分成两块大小相同的区域
- 垃圾回收结束后，将所有的存活对象复制到另一块区域，并一次性清空当前区域。
- 解决了空间碎片化问题

缺点：

1. 浪费内存

#### 标记-整理算法

- 标记需要回收的对象
- 排序，整理待回收的对象在一段内存空间中，直接一次性清除。
- 在内存空间不是很凌乱的时候使用。

缺点：

1. 效率比前两者低
2. 极端情况下会导致程序停顿 Stop The World

### 垃圾收集器的实现

#### Serial收集器 jdk1.3.1之前

- 单线程收集器，当开始垃圾收集的时候会暂停所有线程，直到收集工作结束。
- 新生代收集算法采用标记复制算法，老年代标记整理算法。
- 设计简单高效、在用户桌面场景中内存一般不大。一般用于图形化应用程序。

#### ParNew收集器

- 多线程版Serial收集器。

#### Parallel Scavenge / Parallel Old收集器

新生代 标记复制算法

老年代 标记整理算法

- 能自动衡量吞吐量，根据吞吐量决定垃圾回收的时间。

- jdk8

显示GC日志

```java
// 编译设置
-XX: +PrintGCDetails
```

#### CMS收集器

- 让垃圾收集线程与用户线程同时工作。
- 标记清除
- 垃圾回收阶段：
  - 初始标记（暂停用户线程）标记出GC Roots能够直接关联到的对象
  - 并发标记：从GC Roots开始遍历对象图，可以与垃圾收集线程并发运行。
  - 重新标记：（暂停用户线程）
  - 并发清除：直接将所有标记好的无用对象进行删除，可以并发运行

缺点：

1. 标记清除算法会产生大量内存碎片，导致可用连续空间变少，会有更高概率出发Full GC，占用一部分系统资源，导致运行速度一定程度上减慢。

### Garbage First (G1)收集器 JDK7

- 将Java堆划分为`2048`个大小相同的独立`Region`块，整体控制在1MB-32MB之间都为2的N次幂。生命周期内不会改变。
- 每一个`Region`都可以自由扮演（Eden、Survivor和老年代），收集器根据角色来采用回收策略。
- 存在一个Humongous区，专门存放大对象（大小超过`Region`容量一半的对象）
- 回收过程与CMS相似
- 步骤

![image-20220317211517244](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211517244.png)

### 元空间

JDK8之前Hotspot虚拟机方法区拥有永久代，但是永久代中的数据可能会产生溢出

在JDK8以后，永久代不再存在于堆内存区，而是直接将本地内存作为元空间(**Metaspace**)，物理内存有多大，元空间有多大。这样永久代的空间分配问题就解决了。

![image-20220317211506830](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211506830.png)

#### 其他引用类型

- 强引用：`Object o = new Object()`
  - 如果需要方法中存在强引用，如果要回收强引用对象，要么此方法运行结束，要么引用连接断开，否则被引用的对象是无法被判定为可回收的。
  - 当内存不足时，JVM会抛出OOM
- 软引用：
  - 当内存快要溢出时，会清理软引用对象。
  - 软引用说明
    - 软引用可以使java更好地管理内存，防止内存溢出，避免crash。

    - 处理占用内存较大、生命周期较长，但使用不频繁的对象时应精良应用该技术。

    - 在某些时候对软引用的使用会降低应用的运行效率与性能，例如：应用软引用的对象的**初始化过程较为耗时**，或者对象的**状态在程序的运行过程中发生了变化**，都会给重新创建对象与初始化对象带来不同程度的麻烦，有些时候我们要权衡利弊择时应用。

```java
public class Main {
  public static void main(String[] args) {
    // 强引用 Object obj = new Object();
    // 软引用
    SoftReference<Object> reference = new SoftReference<>(new Object());
    // 使用get方法获取对象
    System.out.println(reference.get());
  }
}
```

- 弱引用：
  - 垃圾回收时，不管内存空间是否充足，都会回收

```java
WeakReference<Object> reference = new WeakReference<>(new Object());
```

- 虚引用：
  - 随时会被回收。

```java
PhantomReference<Object> reference = new PhantomReference<>(new Object);
```

## 类加载

### 类信息

- 字节码文件魔数`CAFEBABE`，通过这个区分是否为字节码。 34 -> 3* 16+4=52 代表jdk8

### ASM字节码框架

- 利用ASM机制手动创建Main类

```java
ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS); // 自动计算导入的大小。
writer.visit(V1_8, ACC_PUBLIC, "com/test/Main", null, "java/lang/Object", null);

```

### 类加载机制

- 把字节码文件加载到内存中的过程。
- 触发类加载：`new` 、`getstatic` `putstatic` `invokestatic`

#### 类的加载步骤

1. 加载 Loading 获取类文件输入流，交给类加载器加载。

   `java.class.getClass()` 堆内存中的class名

   创建数组时不会自动加载类。

2. 校验 Verification 

   - 检查魔数
   - 检查版本号
   - 完整性

3. 准备阶段： 分配内存，为部分字段设定初始值。（系统初始值）

   - 赋初始值时，类中的静态基本类型为默认零值，只有在对象实例化时才会赋值

   - 但是如果类字段属性表中存在`ConstantValue`属性，在准备阶段虚拟机就会根据`ConstantValue`赋值

     `public static final int value = 123;`

4. 解析阶段：将常量池内符号的引用替换为直接引用，引用变量指向内存对象。

5. 最后初始化阶段`<clinit>`

   - `<clinit>()`为类变量与静态变量以及静态代码块。初始化的顺序为先执行父类的，再执行子类。因此最先执行的一定是`Object`类。
   - 初始化为线程安全的，如果多个线程同时初始化一个类，那么只有一个线程会执行`<clinit>()`方法 ，其他线程都会被阻塞。但是当一个线程初始化完成后，其他恢复被阻塞的线程不会执行`<clinit>()`方法，一个类加载器只会初始化一个类一次。

### 类加载器

- 提供类加载器
- 默认都适用java的类加载器加载。

> 每个类都在堆中有唯一的Class对象（不正确）

使用不同的类加载器加载得到的类不是同一个类。

1. Main类：AppClassLoader加载。
2. JDK内部类：BootstrapClassLoader加载。

![image-20220317211452589](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220317211452589.png)

### 双亲委派模型

JVM中的类加载器包含：启动类加载器以及其他类加载器。

当一个类加载器收到类加载的请求时，会首先将类加载请求传递给它的父加载器。父加载器与子加载器之间不是通过继承，而是通过结合的方式实现的。

这样做的好处是，保证单例，比如加载类Object，无论哪一个类加载器需要加载这个类，都会为拍给启动类加载器来完成。这样就保证了Object类在各种环境中都是同一个类。

jdk9与之前的双亲委派模式相比有了一些变化，变化源自于jdk9引入的模块化jar。在一个类加载要委派给父加载器之前，需要先判断是否能够归属到对应系统模块中，如果可以找到，则要优先委派给负责那个模块的类加载器去完成。

# Java版本特性

## Java8

### Optional方法

- 目的是为了解决空指针问题
- Optional 是用来作为方法返回值的
- Optional 是为了清晰地表达返回值中没有结果的可能性
- 且如果直接返回 null 很可能导致调用端产生错误（尤其是NullPointerException）

https://zhuanlan.zhihu.com/p/128481434/

```java
optionalValue.orElse("no data"); // 表示为如果为null则默认值
orElseThorw(Exception : new); // 为null抛出异常
ifpresent(); // 是否存在
flatMap(); // 用于当前Optional的结果，或者为空时，返回一个空Optional
Optional<String> optionalValue = Optional.empty();
```

### Stream



## Java9



# 数据结构算法

## 数组

### 数组基础

- 数组在内存中连续存储。

### 二分法

#### 704. 二分查找

[力扣题目链接](https://leetcode-cn.com/problems/binary-search/)

```java
class solution {
  public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while(left <= right) {
      int mid = left + (right - left)/2;
      
      if (nums[mid] > target) {
        right = mid - 1;
      } else if (nums[mid] < target) {
        left = mid + 1;
      } else {
        return mid;
      }
    }
    return -1; // 没找到
  }
}
```

1. 可以使用二分法解决的问题：有序数组、数组中无重复元素。

### 滑动窗口

[力扣题目链接](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

* [904.水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)
* [76.最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

模板：

```java
class Solution {

    // 滑动窗口
    public int minSubArrayLen(int s, int[] nums) {
        int left = 0;
        int sum = 0;
        int result = Integer.MAX_VALUE;
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while (sum >= s) {
                result = Math.min(result, right - left + 1);
                sum -= nums[left++];
            }
        }
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```

### 双指针



## 链表

### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

- 分制

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) {
            return null;
        } else if (lists.length == 1) {
            return lists[0];
        } else if (lists.length == 2) {
            return mergeTwoList(lists[0], lists[1]);
        } else {
            int i = 0;
            while (i < lists.length-1) {
                lists[i+1] = mergeTwoList(lists[i], lists[i+1]);
                i+=1;
            }
            return lists[lists.length-1];
        }
    }
    public ListNode mergeTwoList(ListNode list1, ListNode list2) {
        while (list1 == null && list2 == null) {
            return null;
        }
        ListNode dummy = new ListNode(0);
        ListNode p = dummy;

        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                ListNode temp = list1.next;
                p.next = list1;
                list1.next = null;
                list1 = temp;
            } else {
                ListNode temp = list2.next;
                p.next = list2;
                list2.next = null;
                list2 = temp;
            }
            p = p.next;
        }
        if (list1 == null) {
            p.next = list2;
        }
        if (list2 == null) {
            p.next = list1;
        }
        return dummy.next;
    }
}
```

## 栈

### 单调栈：

- 单调栈就是一个栈，每次遇到一个新元素，会与栈顶元素比较，如果比栈顶元素大，则入栈，否则则将栈顶元素弹出后继续比较，直到栈顶元素小于待插入元素后，将该元素插入。
- 最终的结果就是，栈中的元素是单调的。
- 适合解决的问题：*寻找左边和右边的位置，寻找到第一个比当前元素大（小）的那个元素的位置。*

## 图

- dfs

```java
//  二进制矩阵中的最短路径

```

- bfs

![image-20220319133340337](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220319133340337.png)

```java
// bfs模板
class Solution {
  public int shortestPathBinaryMatrix(int[][] grid) {
    
        if (grid == null || grid.length == 0 || grid[0].length == 0 || grid[0][0] == 1) {
            return -1;
        }

        int[] dx = {0, 0, 1, -1, 1, -1, 1, -1}; 
        int[] dy = {1, -1, 0, 0, -1, 1, 1, -1};
				// 定义队列
        Queue<int[]> queue = new LinkedList<>();
        int m = grid.length, n = grid[0].length;
        
        if(grid[0][0] == 0) {
            queue.offer(new int[] {0,0});
        }
        grid[0][0] = 1;
        int path = 1;
        int[] point = null;
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size-- > 0) {
                point = queue.poll();
                int x = point[0], y = point[1];
                if (x == m-1 && y == n-1) {
                    return path;
                }

                for (int i = 0; i < 8; i++) {
                    int x1 = x + dx[i];
                    int y1 = y + dy[i];
                    if (x1 < 0 || x1 >= grid.length || y1 < 0 || y1 >= grid[0].length || grid[x1][y1] != 0) {
                        continue;
                    }
                    queue.add(new int[] {x1, y1});
                    grid[x1][y1] = 1;
                }
            }
            path++;
        }
        return -1;
    }
}
```

## 回溯

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> temp = new ArrayList<>();
        find(res, temp, candidates, target, 0);
        return res;
    }

    public void find(List<List<Integer>> listAll, List<Integer> tmp, int[] candidates, int target, int num) {
        if (target == 0) {
            listAll.add(tmp);
            return;
        }
        if (target < candidates[0]) {
            return;
        }
        for (int i = num; i < candidates.length && candidates[i] <= target; i++) {
            List<Integer> list = new ArrayList<>(tmp);
            list.add(candidates[i]);
            find(listAll, list, candidates, target-candidates[i], i);
        }
    }
}
```

#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> tmp = new ArrayList<>();
        boolean[] flag = new boolean[candidates.length];
        Arrays.sort(candidates);
        dfs(res, tmp, candidates, target, 0, flag);
        return res;
    }

    public void dfs(List<List<Integer>> allList, List<Integer> tmp,int[] candidates, int target, int num, boolean[] flag) {
        if (target == 0) {
            allList.add(tmp);
            return;
        }
        if (candidates[0] > target) {
            return;
        }
        for (int i = num; i < candidates.length && candidates[i] <= target; i++) {
            if (i > 0 && candidates[i] == candidates[i-1] && !flag[i-1]) {
                continue;
            }
            flag[i] = true;
            List<Integer> list = new ArrayList<>(tmp);
            list.add(candidates[i]);
            dfs(allList, list, candidates, target-candidates[i], i+1, flag);
            flag[i] = false;

        }
    }
}
```



# 数据库

## MySQL

### mysql普通索引与组合索引

- 普通索引
  - 主键索引
    - 在创建表的时候对主键创建的索引
  - 普通索引
    - 可以对其他列创建索引
  - 唯一索引：
    - 与普通索引类似，但是只能创建在值唯一的列上，允许有空
  - 组合索引：
    - 最左前缀：
      - 对三个列（a,b,c）创建组合索引时，会产生 （a, b, c） (a, b)  (a)这三种索引。

- 索引建立的时机：
  - 一般经常需要通过where join查询的列需要添加索引。

- 无法使用到索引的情况
  1. like '%comp';  // 模糊查询
  2. 组合索引时： (b, c) 这种where组合
  3. 包含有NULL值的列不会使用索引
  4. 在列上进行计算会导致索引失效：
     - `select * from users where YEAR(adddate) < 2007` // 这种方式不回使用索引
     - `select * from users where adddate < '2007-01-01' ` // 能够使用索引
  5. Not in 和`<>`

- 索引在物理机上的问题：
  - 建立索引需要产生索引文件
  - 对于大表以及索引复杂的表，会产生大量的索引文件
  - 索引加快select的速度，但是会减慢insert和update的速度，因为 每次insert或者update会同时更新索引文件。

### MySQL查询语句执行原理

```sql
# 查询语句
SELECT DISTINCT
	列
FROM
	表
	JOIN 表2 ON 条件
WHERE
	条件
GROUP BY
	列
HAVING 
	条件
ORDER BY
	列
LIMIT 
	x
```

作用：

1. 得到所有表的记录
2. 根据where中的单表条件来过滤记录
3. 对多表查询计算笛卡尔积，获得笛卡尔积记录，同时根据ON后的条件来过滤笛卡尔积的记录。
4. 外连接：
   1. 左外连接，把左表没有参加过笛卡尔积运算的记录全部补全，右表补null
   2. 右外连接相反
5. 根据group by分组
6. 针对聚合函数使用having。利用聚合函数对非分组列进行计算。
7. 添加需要增加的列
8. 去掉不需要的列
9. 根据having中的条件进行过滤
10. 去重
11. 排序
12. 分页

![image-20220415140245533](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220415140245533.png)

MySQL可以分为Server层和存储引擎层。

- Server层包含MySQL的大多数核心服务功能及所有内置函数（日期、时间、数学、加密等）。跨存储引擎的功能都在这一层实现，如存储过程、触发器、视图等。
- 存储引擎层负责数据的存储和提取。最常用的引擎是InnoDB。

也就是说，你执行 create table 建表时，如果不指定引擎类型，默认使用InnoDB，如若想使用不同的引擎：create table(...) engine = MyISAM; 即可。

从图中不难看出，不同的存储引擎共用一个**Server层**，下面一一介绍各组件的作用

#### 连接器

- 负责跟客户端建立连接（TCP连接，三次握手）、获取权限，维持和管理连接。

```sql
mysql -h$ip -P$port -u$user -p$password # 连接语句
```

- 客户端如果太长时间没动静，连接器会自动断开连接。时间是由参数wait_timeout控制，默认8小时。（数据库都是长连接）
- MySQL执行过程中的临时使用的内存是管理再连接对象中的，这些资源只有在连接断开的时候才会释放，因此长连接容易导致内存占用太大，而被系统杀掉（out of memory)，就是MySQL的**异常重启**

- MySQL异常重启的解决办法：
  1. 定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，再查询时再重连。
  2. MySQL 5.7后，每次执行一个大查询后，通过执行mysql_reset_connection来重新初始化连接资源。

#### 查询缓存

1. 当连接建立完成后就可以执行SELECT语句了。执行逻辑进入第二步：查询缓存。
2. MySQL拿到一个查询请求后，会先查询缓存，查询过去是否查询过该语句。执行过的语句可能会以key-value的形式缓存在内存中。**key是查询语句，value是查询结果。**如果能直接在缓存中找到key，那么这个value就会直接返回给客户端。
3. **但是现在不建议使用查询缓存！！**
   1. 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空
   2. **MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。**

#### 分析器-Parser

- 对sql进行解析，即：词法分析、语法分析。"You have an error in your SQL syntax"报错。
- 词法分析
  - 关键词 UPDATE / SELECT
  - 表列名 sheet
  - 常量 "xx"
  - 运算符 + -
  - 结束符 ;

- 语法分析
  - 检查语法是否合法


#### 优化器-Optimizer

- 经过分析器后，在执行语句之前需要对语句进行优化。
- 优化器是在表中有多个索引时，决定使用哪个索引；或者在一个语句有多表关联（join）时，决定连接顺序。

如：`select * from t1 join t2 on t1.id = t2.id where t1.c=10 and t2.d=20`

- 可以先从t1中取c=10的记录再根据id关联到表2，再判断表2中d是否等于20
- 也可以反过来

这两种方法都是内连接，结果都是一样的，但是效率不同。优化器决定执行方案。

优化方式：

- 基于规则的优化（**RBO** Rule Base Optimizer）
  - 条件化简
  - Scan优化
    - 唯一索引
    - 普通索引
    - 全表扫描
- 基于代价的优化（**CBO** Cost Base Optimizer)
  - 以时间作为标杆来衡量。

#### 执行器

- 执行sql语句
- 开始执行时，先判断对表T有没有查询权限，如果没有则返回权限错误。在实现上：如果命中查询缓存，会在查询缓存返回结果的时候做权限验证。
- `mysql> SELECT * FROM T WHERE ID=10; ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'`
- 如果有权限，则会打开表继续执行。打开表时，引擎会根据表的引擎定义，去使用这个引擎提供的接口。

如：从表T中赵ID字段没有索引：

1. 调用InnoDB引擎接口取第一行，判断ID是否为10，如果是则存入结果集中，如果不是则跳过。
2. 调用接口取下一行，重复直到最后一行。
3. 将结果集返回给客户端。

火山模型：

- 每个Operator调用Next操作，访问下层Operator，获得下层Operator返回的一行数据，计算后将这行数据返回给上层
- 优点：每个算子独立抽象实现，相互之间没有耦合，逻辑简单
- 缺点，每计算一条数据有多次函数调用开销，导致CPU效率不高。

### MySQL更新语句原理

- 更新流程涉及两个重要的日志模块，**redo log(重做日志)和 bin log(归档日志)**

  #### Redo log(重做日志) InnoDB引擎独有

  - redo log通常是物理日志，记录的是数据页的物理修改。它是用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)
  - 包含两个部分：
    - 内存中的日志缓冲(redo log buffer)：是易失性的；
    - 磁盘上的重做日志文件(redo log file)：是持久的；
  - InnoDB通过 force log at commit机制实现持久化事务，即在事务提交时必须先将该事务的所有事务日志写入到**磁盘上的redo log file中进行持久化**。（由于写磁盘速度很慢，因此IO成本很高）

- WAL技术（Write-Ahead Logging）这个技术的关键在于就是**先写日志，再写磁盘**。

  - 当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。
  - 同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。这样除了能增加性能，也能减少I/O操作的压力。

- 为了确保每次日志都能写入到事务日志文件中，在每次将log buffer(日志缓冲)中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作(即**fsync()系统调用**)。因为MySQL是工作在用户空间的，MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件)，中间还要经过操作系统内核空间的OS buffer，调用fysnc()的作用就是将OS buffer中的日志push到磁盘上的log file中。

![image-20220415153608424](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220415153608424.png)

- MySQL支持用户自定义在commit时如何将log buffer中的日志刷到log file中。通过变量

  innodb_flush_log_at_trx_commit 值来决定。

  `SHOW VARIABLES LIKE '%innodb_flush%';`

  该变量有三种值：0、1、2，缺省为1。但需注意的是，这个变量只是控制commit动作是否刷新log buffer到磁盘。

  - **当设置为1时**，**事务每次提交都会**将log buffer中的日志写入OS buffer并调用fsync()刷到log file on disk中。这种方式即使系统崩溃也不会丢失任何数据，但是每次提交都会写入磁盘，I/O性能较差。
  - **当设置为0时**，**事务提交时不会将log buffer中日志写入到os buffer，**而是**每秒**写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。
  - **当设置为2时**，**每次提交都仅写入到os buffer**，然后是**每秒调用**fsync()将os buffer中的日志写入到log file on disk。

![image-20220415153833217](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220415153833217.png)

#### 日志刷盘

![image-20220415154053149](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220415154053149.png)

- write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。
- write pos 和 checkpoint 之间的是还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示新的操作满了，这时候不能再执行新的更新，**得停下来先擦掉一些记录**，把 checkpoint 推进一下。
- **当redo log把log file push到磁盘时，log file的记录就会被清除。**

所以有了 redo log，**InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe**。**redo log的作用，是在innoDB 中恢复已经Commit但是没有写入数据库的数据。**

#### bin log(归档 log)

- Server层的日志成为bin log。

  - Bin log属于逻辑日志，是以**二进制**形式记录的。redo log记录的是物理格式上的日志，bin log记录的是数据库中**每个页(页表)**的修改。仅仅只有bin log是没有crash-safe能力的

  - bin log有两种模式，**statement格式是记录sql语句，row格式是记录行内容，记两条，更新前和更新后都有**。

    - 当sync_log这个参数设置成1时，表示每次事务的binlog都会持久化到磁盘。通过下面命令查看sync_log=?

      `SHOW VARLABLES LIKE '%sync%';`

    - 这个参数对MySQL是至关重要的，不仅影响性能，而且影响数据的完整性。同时你可以设置成0或者2、3等等(根据自己的需求而设定)。MySQL会根据你设定的参数来判断你在第几次事务commit之后需要同步到磁盘上。

- 为什么会有两份日志？

  - 因为最开始MySQL里并没有InnoDB引擎。MySQL自带的是MyISAM，但是MyISAM并没有crash-safe的能力，binlog只能用于归档，InnoDB是另一个公司以插件形式引入MySQL的，既然binlog没有crash-safe能力，InnoDB就使用自己的日志系统 --> redolog来实现存储

- binlog和redolog的区别：

  - redolog是InnoDB独有的。binlog是MySQL的Server层实现的，所有引擎皆可使用。
  - redolog是物理日志，记录了某个数据页上做了什么修改。binlog是逻辑日志，记录了这个语句的原始逻辑，比如给 id=2 的用户加1块钱。
  - redolog是循环写的，空间固定并会使用完，用完后需要擦掉(push到磁盘)才能继续使用。而binlog是可以追加写入的。意思就是文件写到一定大小就会自动创建下一个文件开始写，并不会覆盖上一个文件。

#### 两阶段提交

![image-20220415154921359](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220415154921359.png)

1. 执行器先找引擎取ID=2这一行，ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存再返回。
2. 执行器拿到返回的行数据，把这个值加1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redolog里，此时redolog处于prepare状态，然后告知执行器执行完成，就可以commit事务了。
4. 执行器生成这个操作的binlog，并把binlog写入磁盘。
5. 执行器调用引擎的commit接口，把刚刚的redolog改成commit状态，更新完成

**将redolog push到磁盘上需要完成两个步骤：prepare和commit。这就是"两阶段提交"**

![image-20220415160348932](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220415160348932.png)

1. InnoDB redo log push进磁盘，InnoDB事务进入prepare状态。
2. 如果前面prepare成功，binlog写盘，那么再继续将事务日志持久化到binlog，如果持久化成功，那么InnoDB事务进入commit状态（在redolog里面写一个commit记录）

每一个事务binlog的末尾，会记录一个XID event，标志着事务是否commit成功，也就是说，recovery过程中，binlog最后一个XID event之后的内容都应该被purge。

#### MySQL数据恢复

系统备份中保存binlog，以及系统的整库备份。

MySQL备份命令：`mysqldump -u账号 -ppassword -hip -Pport --databases 数据库名 > xxx.sql`

##### docker容器通过binlog恢复mysql数据

1. docker 进入容器MySQL命令：**docker exec -it {容器名/容器ID} bash**

2. 进入mysql：**mysql -u{用户名} -p{密码}**

3. 查看binlog是否开启：**mysql > show variables like '%log_bin%';**

![image-20220415162244808](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220415162244808.png)

![image-20220415162300157](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220415162300157.png)

**# --stop-position=xxx 停止节点的编号** 

**mysqlbinlog -v binlog.000008 --stop-position=xxx -v | mysql -u{账号} -p{密码}**

只要没有Error，最后去数据库查看有无恢复即可~ 

#### 小结

- redo log用于保证**crash-safe能力。**innodb_flush_log_at_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数建议设置成1(默认也是1)，这样可以保证MySQL异常重启之后数据不丢失。
- sync_binlog这个参数设置成 1 时，**表示每次事务的 binlog 都持久化到磁盘**。这个参数我也建议你设置成 1(默认也是1)，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

### 并发事务产生的问题：

- 脏读： dirty read
  - 事务A和事务B，数据a=1，事务A修改a为2，但是事务A还未结束，此时事务2读取了**a为2**，此时事务B发生了脏读。
- 丢失修改： lost to modify
  - 事务A和事务B同时读取数据a=1，并同时对a+1，事务A提交后a=2， 事务B提交a=2，此时事务A的修改丢失。
- 不可重复读：Unrepeatableread
  - 事务A中多次读取同一个数据a，此时事务B同时对数据**修改**，会导致事务A中读取到同一个数据不太一样。
- 幻读：Phantom read
  - 事务A中多次读取，途中事务B**新增或删除**数据，导致数据A中读取到了不该读到的数据。

### 事务隔离

- ACID
  - Atomicity [原子性]
  - Consistency [一致性]
  - Isolation [隔离性]
  - Durability [持久性]
- 多事务同时进行时，会出现脏读(dirty read)、不可重复读(non-repeatable read)、幻读(phantom read)等问题。
  - 为了解决这些问题就有了“隔离级别”的概念。首先，隔离得越严实，效率就会越低。所以很多时候，我们都要在二者之间寻找一个平衡点。

#### 隔离级别：

1. **读未提交(read uncommitted)**：一个事务还没提交时，它做的变更就能被别的事务看到。
2. **读已提交(read committed)**：一个事务提交之后，它做的变更才会被其他事务看到。
3. **可重复读(repeatable read)**：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务是不可见的。
4. **串行化(serializable)**：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

- **读已提交**和**可重复读**：假设数据表T中只有一列，value=1，下面按照时间顺序执行两个事务

![image-20220415163007470](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220415163007470.png)

- 隔离级别是“读已提交”，则V1是1，V2是2。事务B的更新在提交后才能被A看到。所以V3的值也是2.
- 隔离级别是“可重复读”，则V1、V2值是1，V3是2。之所以V2还是1，遵循的就是**事务在执行期间看到的数据前后必须是一致的**。

在实现上，数据库里会创建一个视图，访问的时候以视图的逻辑结果为准。**在“可重复读”隔离级别下，*这个视图是在事务启动时创建的*，整个事务存在期间都用这个视图。在“读已提交”隔离级别下，*这个视图是在每个SQL语句开始执行的时候创建的*。** “读未提交”隔离级别下直接返回记录上的最新值，没有视图的概念。而“串行化”下直接用加锁的方式来避免并行访问。

（**MySQL默认的隔离级别是“可重复读”**）

- 查询隔离级别：**SHOW VARIABLES LIKE 'transaction_isolation';**

#### 事务隔离的实现

- undo log（回滚日志）
  - 每条记录在更新的时候会同时记录一条回滚操作。通过回滚操作，都可以得到一个状态的值。
  - 保存了事务发生之前的数据版本，可以用于回滚。同时可以提供多版本并发控制下的读(MVCC)，即非锁定读。
- 假设一个值从1按顺序update成2、3、4，回滚日志操作记录如下：

![image-20220415200415127](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220415200415127.png)

- 当前值为4，当查询这条记录的时候，不同时刻的启动事务会有不同的read-view。
- read-view ABC的值分别为124，是数据库的多版本并发控制（MVCC）
- 同时如果有一个事务将4改成5，这个事务与read-viewABC是不会冲突的。
- 回滚日志的删除：系统会判断当没有事务再需要用到这些回滚日志时，回滚日志就会被删除。（即当系统里面没有比这个回滚日志更早的read-view时）

不建议用长事务：

- 长事务会导致系统里存在很老的事务时图。所以这个事务提交之前，数据库里它可能用到的回滚记录都必须保留，因此会导致占用大量的存储空间。除了影响回滚段以外，还会占用锁资源。

#### 事务的启动方式

1. 显示启动事务语句，begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit或rollback语句，或者断开连接。

如果想减少语句的交互次数，对于一个需要频繁使用事务的业务来说。可以使用commit work and chain语法，在autocommit=1的情况下，则是提交事务并自动启动下一个事务，省去了begin语句的开销。好处就是明确地知道哪个语句是否处于事务中

你可以在information_scherma库的innodb_trx这个表中查询长事务：

**SELECT \* FROM information_schema.innodb_trx**

**WHERE TIME_TO_SEC(timediff(now(),trx_started))>60;**

### 数据库部分语法

#### IF表达式：

```sql
IF( expr1 , expr2 , expr3 )
- expr1 ? expr2 : expr3;

select *,if(book_name='java','已卖完','有货') as product_status from book where price =50

SELECT
    SUM(IF(state=1,1,0)) AS 旷工数unNo,
    SUM(IF(state=2,1,0)) AS 迟到数overNo
FROM kqinfo          
GROUP BY month_date,user_id HAVING (unNo+overNo) > 0
```

```sql
IFNULL( expr1 , expr2 )
SELECT IFNULL(NULL,"11");
-> 11
 
SELECT IFNULL("00","11");
-> 00

NULLIF(expr1,expr2)：如果两个参数相等则返回NULL，否则返回第一个参数的值expr1
```

#### CASE

- 将CASE后的value值与compare_value进行比较，一旦和某个value相等，则返回后面的res

```sql
CASE value
	WHEN [compare_value] THEN res
	[WHEN [compare_value] THEN  result ...] 
  [ELSE  result]  END
  
  
mysql> select userid,case salary                                             
    -> when 1000 then 'low'
    -> when 2000 then 'med'
    -> when 3000 then 'high'
    -> else '无效值' end salary_grade
    -> from salary_tab;
+--------+--------------+
| userid | salary_grade |
+--------+--------------+
|      1 | low          |
|      2 | med          |
|      3 | high         |
|      4 | 无效值        |
|      5 | low          |
+--------+--------------+
```

#### searched case

- condition 条件判断，一旦condition为true则返回后面的result

```sql
CASE
    WHEN [condition] THEN result
    [WHEN [condition] THEN result ...]
    [ELSE result]  END
    
    
mysql> select userid,case
    -> when salary<=1000 then 'low'
    -> when salary=2000 then 'med'
    -> when salary>=3000 then 'high'
    -> else '无效值' end salary_grade
    -> from salary_tab;
+--------+--------------+
| userid | salary_grade |
+--------+--------------+
|      1 | low          |
|      2 | med          |
|      3 | high         |
|      4 | 无效值        |
|      5 | low          |
+--------+--------------+
```

https://www.cnblogs.com/better-farther-world2099/articles/14886136.html

#### update

```sql
update
  sheet1 t
set
	t.col = 'xx'
```

#### insert

```sql
insert into 
	table_name
	(col1, col2, col3)
	values
	(val1, val2, val3)
	// 对指定列添加数据
  insert into 
  table
  values
  (val1, val2, val3,...);
  按照表中列的顺序添加
```

#### delete

```sql
delete
from
table
where
xxx

// 普通delete
delete 
t1
from
tb1 as t1,
tb2 as t2
where
t1.xx = t2.xx and t1.id > t2.id
```

### 数据库存储引擎

#### InnoDB

![image-20220604192058935](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220604192058935.png)

![image-20220604192131129](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220604192131129.png)

内存：数据缓存

磁盘：真实数据、事务日志、临时表等

**Buffer Pool**

每个BufferPool有多个instance

每个instance有多个chunk

通过LRU管理内存空间。

**B+ Tree** 索引

二分查找树。

二分查找树方便点查，查到对应位置的内容。叶子结点双向链表，方便查询范围内容

### 数据库状态回滚

Undo Log

### Isolation   隔离性

锁机制实现

### Durability 一致性

Redo Log

日志写盘，提交。

### 高可用

3AZ高可用

![image-20220604194329902](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220604194329902.png)

# 开发相关

本地版本控制：RCS

集中版本控制：SVN

## git

Git: 分布式版本控制

```git
git init
 --initial-branch 初始化分支
 --bare  创建裸仓库
 --template 根据模板创建
 
 查看commit文件
 tree .git
 git cat-file -p xx
 
 # tag object
 git tag xxx
```

![image-20220524195654472](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220524195654472.png)

## servlet

init() --> 初始化

service() --> 处理请求

destory () --> 销毁（停止）

Servlet生命周期分成3个阶段：

1）初始化阶段：调用init方法

2）响应客户请求：调用service

3）终止：调用destory方法

初始化阶段：在下列时刻servlet容器装载servlet

1  servlet容器启动时，自动装载某些servlet

2  在servlet容器启动后，客户首次向servlet发送请求

3  servlet类文件被更新之后，重新装载servlet

Servlet被装载之后，servlet容器创建一个servlet'对象并调用servlet的init方法，在servlet生命周期内，init方法只能被调用一次。servlet工作原理：客户端发起一个请求，servlet调用service方法时请求进行响应，service对请求的方式进行了匹配，选择调用dopost或者doget等这些方法，然后进入对应方法中调用逻辑层的方法，实现对客户的响应。

响应客户请求：对于用户到达servlet的请求，servlet容器会创建特定于该请求的servletrequest和servletresponse对象，然后调用servlet的service方法，service方法从servletrequest对象中获取客户请求的信息，处理该请求，并且通过servletresponse对象向客户端返回响应信息。

终止：当web应用终止或者servlet容器终止或servlet容器重新装载servlet新实例时，servlet容器会调用servlet对象的destory方法，在destory方法中可以释放servlet占用的资源





# 开发框架和中间件

## mybatis

### SqlSession



#### mybatis缓存机制：

一级缓存流程图：

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/bb851700.png)

- 一级缓存的范围是SqlSession内部，如果存在多个SqlSession的分布式环境下，数据库读写会产生脏数据，因此建议设定缓存级别为Statement

二级缓存：

多个SqlSession之间共享缓存，需要开启二级缓存。

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/28399eba.png)

- 二级缓存是一个全局变量，同一个namespace下的操作语句都会影响同一个cache。
- 数据的查询执行的流程就是 二级缓存 -> 一级缓存 -> 数据库。

`<setting name="cacheEnabled" value="true"/>`



中间件：

![image-20220426153117748](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220426153117748.png)

## Redis

### 高频问题

#### redis为什么快

- 单线程
- 完全基于内存
- 多路IO复用模型，非阻塞IO
- 构建自己的VM机制。

#### redis 过期字典：

- 通过一个过期字典：hash表，来保存数据的过期时间。

#### redis持久化机制：

- RDB（默认）（Redis DataBase)
  - 默认机制，定时的将内存中的数据以快照的形式存储到硬盘中，
  - 生成文件：dump.rdb
  - 优势：
    - 只有一个文件，简便
    - 容灾性好
    - 性能最大化。使用fork子进程来完成写操作，IO最大化。
    - 使用子进程持久化不影响主进程的IO
    - 数据集较大时，效率更高
  - 缺点：
    - 安全性低，隔一段时间进行持久化，可能会导致数据丢失
- AOF （Append Only File）
  - 每次写命令都会将命令记录到单独的日志文件中，当redis发生重启时，会从持久化日志中恢复数据。
  - 两种方式同时开启时，会优先选择AOF恢复。
  - 优点
    - 数据安全，可以配置appendfsync属性，配置为always时，每次命令都会记录到AOF文件中。
    - 通过**append模式写**文件，即使服务器宕机，也可以通过Redis-checkaof解决一致性问题。
    - rewrite模式：
      - 在文件过大时会对日志文件进行合并重写，删除其中的某些命令
  - 缺点：
    - 文件大，恢复速度慢
    - 数据大时启动效率低


- 两者对比优缺点：
  - AOF比RDB更新频率高，AOF优先使用
  - AOF比RDB更安全也更大
  - RDB比AOF性能好
  - 同时配置时优先AOF

#### value数据结构

（分布式数据结构，数据共享）

##### 字符串String

- `object encoding xxx` 
- 存入时：先判断能否转为int类型，如果可以则转为int，否则则String
- 应用场景：
  - 单值缓存
  - 对象缓存（JSON格式字符串）
  - 分布式锁
    - SETNX xxxx:xxx true // 获取成功 false ：失败
  - 计数器 INCR
    - 分库分表，用redis实现自增id
    - Incrby orderId 100 // 一次获取100个id，在内存中++

##### 哈希hash

- 双层Map 存储对象
- HMSET user 1:name  xxx 1:balance 1888
- HMGET user 1:name 1: bakance 
- 与使用String的区别：
  - 包含大量字段，如果需要修改某个字段
- 实现购物车

##### 列表list

- LPUSH key value // 添加到表头
- RPUSH key value // 到表尾
- LPOP RPOP // 取
- 实现数据结构：
  - Stack LPUSH + LPOP
  - Queue LPUSH + RPOP
  - Blocking MQ 阻塞队列 = LPUSH + BRPOP
- 场景：微博和公众号消息流
  - 每个用户发消息，将消息id LPUSH到粉丝的list中
  - LRANGE msg:{id} 0 4 // 取4条最新 

##### 集合set：

- 集合set

  - SADD key member [member ...] // 添加用户到抽奖集合
  - SMEMBERS key // 查询set所有元素
  - SRANDMEMBER key [count]  // 随机抽几个  SPOP 抽完后删除
  - 抽奖程序
  - 点赞：
    - SADD like:{id} {userid} // 点赞
    - SREM like:{id} {userId} // 取消点赞
    - SISMEMBER list // 是否点赞
    - SMEMBERS like:{id} // 获取点赞用户列表
    - 关注模型：（共同关注0），求交集(使用集合)

- 有序集合zset

  ![image-20220426212802980](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220426212802980.png)

  场景：

  - 排行榜

    ![image-20220426212919175](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220426212919175.png)

```
SINTER set1 set2 set2 -> 交集
SUNION 并集
SISMEMBER 
SDIFF  求差集  set1 - set2和set3的并集
```

##### bitmap

- 用来存储是否已签到，是否登陆等信息
- 存储二进制数字 0 1

##### 压缩列表

- zipList O(N) 
- 去掉链表的指针，记录偏移位置，快速定位元素

##### 跳表：

- jumpList O(logN) 
- 把有序列表改造支持折半查找算法。
- 有序链表建立索引层

压缩链表与跳表切换

```
zset-max-ziplist-entries 128 // 元素超过128，将用skiplist
```

#### 读取与存储

`set k v`

先对key计算hash， 再 % 哈希表的大小存入

动态扩容机制：

#### 一个字符串类型的值能存储最大容量：

512MB

#### Redis如何实现大量数据插入？

这个问题在Redis的官方文档给出了答案，从Redis 2.6开始`redis-cli`支持一种新的被称之为**pipe mode**的新模式用于执行大量数据插入工作。具体可以看官网的详细解释，这里就不再复制粘贴了：https://www.redis.com.cn/topics/mass-insert.html

#### 如何通过Redis实现异步队列？

主要有两种方式

第一种是使用List作为队列，通过RPUSH生产消息， LPOP消费消息

**存在的问题**：如果队列是空的，客户端会不停的pop，陷入死循环

**解决方法**：

- 当lpop没有消息时，可以使用sleep机制先休眠一段时间，然后再检查有没有消息。
- 可以使用blpop命令，在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。这种做法的缺点是只能提供一个消费者消费

第二种方法是pub/sub主题订阅模式，发送者(pub)发送消息，订阅者(sub)接收消息

**存在的问题**：消息的发布是无状态的，无法保证到达，如果订阅者在发送者发布消息时掉线，之后上线也无法接收发布者发送的消息

**解决方法**：使用消息队列

#### 如何通过Redis实现延时队列？

先说下延时队列的使用场景：

- 常见的微信红包场景，A给B发红包，B没有收，1天后钱会退回原账户
- 电商的订单支付场景，订单在半小时内未支付会自动取消

上述场景可以通过定时任务采用数据库/非关系型数据库轮询方案或延迟队列

- Redis实现的延迟队列

  - 可以通过Redis的zset命令实现延迟队列，ZSET是Redis的有序集合，通过`zadd score1 value1`命令向内存中生产消息，并利用设置好的时间戳作为score进行[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，然后通过zrangebysocre 查询符合条件的所有待处理的任务，循环执行，也可以`zrangebyscore key min max withscores limit 0 1` 查询最早的一条任务，来进行消费，如下图（画的第二种，好画点）

    ![image-20220413145913330](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220413145913330.png)

 #### Redis回收使用什么算法？

- LRU算法和引用计数法
  - **LRU算法：淘汰最长时间没有被使用的对象**
  - 引用计数法在学习JVM中也见过的，对于创建的每一个对象都有一个与之关联的计数器，这个计数器记录着该对象被使用的次数，当对象被一个新程序使用时，它的引用计数值会被增1，当对象不再被一个程序使用时，它的引用计数值会被减1，垃圾收集器在进行垃圾回收时，对扫描到的每一个对象判断一下计数器是否等于0，若等于0，就会释放该对象占用的内存空间，简单来说就是**淘汰使用次数最少的对象**（LFU算法）

#### Redis 里面有1亿个 key，其中有 10 个 key 是包含 java，如何将它们全部找出来？

可以使用Redis的KEYS命令，用于查找所有匹配给定模式 pattern 的 key ，虽然时间复杂度为O(n)，但常量时间相当小。

**注意**: 生产环境使用 KEYS命令需要非常小心，在大的数据库上执行命令会影响性能，KEYS指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个命令适合用来调试和特殊操作，像改变键空间布局。

不要在你的代码中使用 KEYS 。如果你需要一个寻找键空间中的key子集，考虑使用 [SCAN](https://redis.com.cn/commands/scan.html) 或 [sets](https://redis.com.cn/topics/data-types#sets)。

#### 生产环境Redis部署



### Redis缓存

- Redis系统架构：

![image-20220413134240574](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220413134240574.png)

#### 突发性热点缓存

瞬间大量请求访问非热点数据，导致全部打到DB上导致DB挂掉。

冷门数据突发大量访问。

- 解决方法：

  - `synchronized` 请求缓存数据

  ```java
  String productStr = redisUtil.get(key);
  if (!StringUtils.isEmpty(productStr)) {
    if (缓存空) {
      redisUtil.set(); // 设置缓存防止缓存穿透
      return null;
    }
    product = JSON.parseObject(...); // 读取数据
    redisUtil.expire(); // 缓存续命
    return product
  }
  
  // 锁对象
  Object obj = new Object(pool);
  
  // DCL模式（单例） 双重检测锁。
  // jdk自带锁都是单机锁，在并发集群中无效
  
  synchronized(obj) {
    //重复查缓存
    // 没查到，查数据库，
  }
  ```

  问题：

  1. jdk自带锁为单机锁
  2. 锁对象

  - 分布式锁 Redisson

    - setnx（排队获取锁）

      取得锁，加锁

  ![image-20220426143433688](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220426143433688.png)

#### 缓存雪崩

- 缓存雪崩是某一时刻出现大规模缓存失效的情况，大量请求直接打在数据库上面可能会导致数据库宕机。
- 原因：
  - Redis宕机
  - 很多key采取了相同的过期时间，同时过期
- 解决办法
  - 搭建Redis集群防止Redis宕机
  - 尽量不要设置相同的过期时间，直接在原有的过期时间上加上随机数
  - 服务降级，（限流）当流量达到一定阈值时，直接返回系统繁忙等，防止过多请求直接打到数据库上。
  - **多级缓存**：添加一层jvm进程级别缓存Map（进程缓存框架）。并发多机。（JVM堆内存）
    - 容量限制。
    - 多机数据不一致

#### 缓存击穿

- 缓存击穿时一个热点的Key有大并发集中对其访问，突然导致这个key 失效了，导致大并发全部打在数据库上，导致数据库压力剧增。 如：商品秒杀，大量用户在抢某商品时商品的key突然过期了，所有请求打在数据库上。
- 解决办法：
  - 随机设置缓存失效时间。
  - 考虑热点key不设置过期时间，避免key失效。
  - 如果缓存失效，可以加锁，只有拿到锁才可以查询数据库，但是容易导致系统性能变差。

#### 缓存穿透（布隆过滤器）

- 缓存穿透是指用户的请求没有经过缓存而直接请求到数据库上，比如用户的key在redis中不存在，或者用户恶意伪造大量不存在的key请求，导致数据库压力太大挂掉。

- 解决办法：

  - 参数校验，对用户id进行校验，直接拦截不合法用户请求。

  - 布隆过滤器，判断这个key在不在数据库中，特点是**如果判断这个key不在数据库中，那么这个key一定不在数据库中，如果判断这个key在数据库中，也不能保证这个key一定在数据库中**。原因是：布隆过滤器适用了hash算法，不同key的hash值一定不通，但相同的hash值不一定能说明两个key相同。

    - 布隆过滤器底层使用bit数组存储数据。

    - 布隆过滤器第一次初始化的时候，会把数据库中所有已存在的key，经过一系列的hash算法计算，算出每个key的位置，**并将该位置的值置为1**，为了减少哈希冲突的影响，**可以对每个key进行多次hash计算**。

    - 现在用户请求都要经过布隆过滤器过滤，只有key的hash为1才可以通过。

      ![image-20220413135619941](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220413135619941.png)

**![image-20220413135529080](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220413135529080.png)**



### 双写一致性

缓存，数据库双写不一致问题：

- 如何保证缓存与数据库双写时的一致性(见分布式一致性问题)

解决：

- redisson分布式锁，在更新和读取的时候加锁：读取和更新加锁。读取，更新缓存后解锁。更新，写入缓存后解锁。
- 优化：

### 读写锁：(解决热点数据并发重建)

- 读锁：可以并行读。
- 写锁：排队串行执行。

```java
RReadWriteLock readWriteLock = redisson.getReadWriteLock(lock);
readWriteLock.readLock.lock();
try {
  
} finally {
  unlock();
}
```



# 开发工具

## SpringBoot

### SpringBoot注解

https://github.com/Snailclimb/JavaGuide/blob/main/docs/system-design/framework/spring/spring-common-annotations.md

# 架构

# 分布式

## RPC

### 跨进程交互方式

- RESTful  WebService HTTP DB MQ RPC
- 异步交互：依赖中间件：MQ、DB:
  - 系统之间互不干扰。
- 同步交互：HTTP、RPC、WS、RESTful
  - 客户端会等待服务端返回

### 现有框架

![image-20220606185424516](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220606185424516.png)

![image-20220606190127615](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220606190127615.png)

- 网络模块
- 序列化模块
- client stub  客户端
- Server stub 服务反射调用

### 技术栈

- 基础知识
  - Javacore、maven、反射
- 动态代理（生成client存根实际调用对象）
  - java动态代理
- 序列化（Java对象与二进制互转
  - fastjson
  - 序列化：java对象转为二进制数组
- 网络通信（tcp长连接（socket
  - Jetty、URLConnection（http

![image-20220606191016369](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220606191016369.png)



- 安全性：网络身份验证，encode数据加密
- 服务端处理能力：自己创建线程池，返回数据时做成队列
- 注册中心：对server地址注册，自动发现地址
- 集成能力：与springboot结合 springboot-starter

## 一致性

- 分布式系统一致性：

- 一致性：

  - 强一致性：当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。强一致性对用户比较友好，但对系统性能影响比较大。
  - 弱一致性：系统并不保证后续进程或者线程的访问都会返回最新的更新过的值。
  - **最终一致性**：也是弱一致性的一种特殊形式，系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。

- 大多数系统都是采用的最终一致性，最终一致性是指系统中所有的副本**经过一段时间的异步同步之后**，**最终能够达到**一个一致性的状态，**也就是说在数据的一致性上存在一个短暂的延迟**。

- 保证一致性最简单的方法就是同时更新数据库和缓存。

  - 先更新数据库，后更新缓存

    - 一般不会有更新缓存的操作，因为很多时候缓存的值并不是直接从数据库中取出来的，而是经过计算得到的，如果数据库写操作频繁，缓存也会频繁更改，性能代价较大，并且更新后的缓存不一定会被访问就又要被修改了。

  - 先更新缓存，后更新数据库

  - **先更新数据库，后删除缓存**（使用更多）

    - 如果更新数据库成功了，删除缓存时没有成功，那么后面每次读取缓存时都是错误的数据。要使用删除重试机制：常见的方案有利用消息队列和数据库的日志。

    - 利用消息队列实现删除重试机制：

      ![image-20220413143140143](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220413143140143.png)

      - 使用消息队列的好处在于：可以保证写到队列中的消息在成功消费之前不会消失，并且在第4步中获取消息时，只有消费成功才会删除消息，否则会继续投递消息给应用程序。
      - 缺点在于系统复杂度高，对业务代码入侵严重。

    - 订阅数据库日志方式删除缓存：

      ![image-20220413143427150](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220413143427150.png)

  - 先删除缓存，后更新数据库

    - 存在问题：

      - 在并发环境下，有两个请求A和B，A是更新操作，B是查询操作
      - 假设A请求先执行，会先删除缓存中的数据，然后去更新数据库
      - B请求查询缓存发现为空，会去查询数据库，并把这个值放到缓存中
      - 在B查询数据库时A还没有完全更新成功，所以B查询并放到缓存中的是旧的值，并且以后每次查询缓存中的值都是错误的旧值

    - 这种情况的解决方法通常是采用**延迟双删**，就是为保证A操作已经完成，最后再删除一次缓存

      ![image-20220413144255877](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220413144255877.png)

    - 延迟时间设置：一般大于B操作读区数据库+写入缓存的时间。一般可以考虑读业务逻辑数据的耗时 + 几百毫秒。

- 对于主从复制、读写分离的数据库：可能会出现：

  - A操作更新主库后，删除了缓存
  - B操作查询缓存没有查到数据，查询从库拿到旧值
  - 主库将新值同步到从库
  - B操作将拿到的旧值写入缓存

- 这就造成了缓存中的是旧值，数据库中的是新值，解决方法还是上面说的**延迟双删**，延迟时间要大于主从复制的时间

## 分布式锁

```java
setnx key value; // SETNX  SET if Not eXists 如果不存在则设置
```

![image-20220411195924081](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220411195924081.png)

![image-20220411200020963](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220411200020963.png)

### redisson

```java
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.16.1</version>
</dependency>
  
RLock redissonLock = redisson.getLock(lockKey);
redissonLock.lock; // setIfAbsent(lockKey, clientId, 30, TimeUnit.SECONDS);

redissonLock.unlock;
```

![image-20220411202352780](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220411202352780.png)

- 锁丢失问题

Zookeeper  分布式应用程序协调服务软件

Redlock redis多节点

500个，分库存段位，分段加锁。分10个，每组50个（轮询）

## SpringCloud

### SpringCloud基础功能

- 服务治理： Spring  Cloud Eureka
- 客户端负载均衡： Spring Cloud Ribbon
- 服务容错保护： Spring  Cloud Hystrix  
- 声明式服务调用： Spring  Cloud Feign
- API网关服务：Spring Cloud Zuul
- 分布式配置中心： Spring Cloud Config

# 微服务

# DevOps

# 设计模式Design pattern

## 创建型模式

### 单例模式

- 是什么

保证整个应用中某个对象有且仅有一个实例

- 解决的问题

单例模式是为了避免创建多个实例而导致资源浪费，并且多个实例多次调用容易导致结果错误。

- 应用场景



- 实现原理

  1. 保证唯一性：
     1. 不允许其他程序中new该对象
     2. 在该类中创建对象
     3. 对外提供一个可以让其他程序获取对象的方法
  2. 对比：
     1. 私有化该类的构造函数
     2. 通过new在本类中创建一个本类对象
     3. 定义一个公有方法，将该类中创建的对象返回

- 实现方式及代码

  - 饿汉式：

    初始化时直接创建对象。劣势：耗费资源。

  ```java
  public class SingletonEHan {
    private SingletonEHan() {} // 私有化构造函数
    
    private static SingletonEHan singletonEHan = new SingletonEHan(); // 静态方法创建对象
    
    public static SingletonHungryMan getInstance() {
      return singletonEHan; // 获取对象的方法
    }
  }
  public static void main(String[] args) {
    SingletonEHan.getInstance();
  }
  
  
  /**
  * 2. 单例模式的饿汉式变换写法[可用]
  * 基本没区别
  */
  private static SingletonEHan singletonEHanTwo = null;
  
  static {
    singletonEHanTwo = new SingletonEHan();
  }
  
  public static SingletonEHan getSingletonEHan() {
    if (singletonEHanTwo == null) {
      singletonEHanTwo = new SingletonEHan();
    }
    return singletonEHanTwo;
  }
  // SingletonEHan instance= SingletonEHan.getSingletonEHan();
  ```

  - 懒汉式

  ```java
  public class SingletonLanHan {
    private SingletonLanHan() {};
    
    private static SingletonLanHan singletonLanHan;
    
    /**
    * 线程不安全
    */
    public static SingletonLanHan getInstance() {
      if (singletonLanHan == null) {
        singletonLanHan = new SingletonLanHan();
      }
      return singletonLanHan;
    }
  }
  
  public class SingletonLanHan {
    private SingletonLanHan() {};
    
    private static SingletonLanHan singletonLanHan;
    
    /**
    * 线程安全，但是效率低（不推荐使用
    * 每次需要获得都要同步
    */
    public static synchronized SingletonLanHan getInstance() {
      if (singletonLanHan == null) {
        singletonLanHan = new SingletonLanHan();
      }
      return singletonLanHan;
    }
  }
  
  /**
  * 单例模式懒汉式[线程不安全，不可用]
  * <p>
  * 虽然加了锁，但是等到第一个线程执行完instance=new Singleton()跳出这个锁时，
  * 另一个进入if语句的线程同样会实例化另外一个Singleton对象，线程不安全的原理跟3类似。
  */
  private static SingletonLanHan instanceThree = null;
  
  public static SingletonLanHan getSingletonLanHanThree() {
    if (instanceThree == null) {
      synchronized (SingletonLanHan.class) {// 线程不安全
        instanceThree = new SingletonLanHan();
      }
    }
    return instanceThree;
  }
  
  /**
  * 懒汉双重校验锁，推荐使用
  *
  */
  private static SingletonLanHan singletonLanHan;
  public static SingletonLanHan getInstance() {
    if (singletonLanHan == null) {
      synchronized (SingletonLanHan.class) {
        if (singletonLanHan == null) {
          singletonLanHan = new SingletonLanHan();
        }
      }
    }
    return singletonLanHan;
  }
  ```

  - 内部类【推荐】

  ```java
  /**
  * 与饿汉式类似
  * 采用类装载机制保证初始化时单线程，
  * 不同之处在于：
  * 饿汉式会在类装载时立刻初始化，而内部类时在调用getInstance()方法时才装载内部类。
  *
  * 优点：避免了线程不安全，延迟加载效率高
  */ 
  public class SingletonIn {
    
    private SingletonIn() {}
    
    private static class SingletonInHolder {
      private static SingletonIn singletonIn = new SingletonIn();
    }
    
    public static SingletonIn getInstance() {
      return SingletonInHolder.singletonIn;
    }
  }
  ```

  - 枚举【推荐】

  ```java
  /**
  * 这里的instance即为SingletonEnum类型的引用所以得到它就可以调用枚举中的方法了。
  * 
  * 利用jdk1.5中的枚举类型来创建单例，避免了线程同步问题，还防止反序列化重新创建对象
  */
  
  public enum SingletonEnum {
    
    instance;
    
    private SingletonEnum() {}
    
    public void method() {
      
    }
    
    // SingletonEnum.instance.method();
  }
  ```

### 工厂模式

- 解决的问题

需要根据不同的type来创建不同的对象，创建的对象往往继承自某个父类

- 使用场景



#### 静态工厂模式

- 项目中的辅助类

  ```java
  TextUtil.isEmpty(); // 类+静态方法。
  ```

#### 简单工厂模式

- 专门定义一个类来负责创建其他类的实例，被创建的实例通常继承自同一个父类。

  ```java
  public class kingFactory {
    
    public King createKing(String name) {
      King king = null;
      switch (name) {
        case "XiJP":
          king = new XiKingVirus();
          break;
        case "JiangZM":
          king = new JiangLifeVirus();
          break;
        case "MaoZD":
          king = new LaRouVirus();
          break;
        default: // 否则默认创建
          king = new ChinaKing();
          break;
      }
      return king;
    }
  }
  
  // King roujiamo = factory.createKing(type);
  // roujiamo.prepare();
  // ... 
  // return roujiamo;
  ```

#### 工厂方法模式

- 实现代码：

定义一个创建对象的接口，由子类决定实例化哪个类，将类的实例化推迟到子类。

1. 定义创建抽象方法接口`public abstract KingChina fuckChina(String type)`

2. 实现抽象方法

```java
public abstract class RouJiaMoStore {
  public abstract RouJiaMo createRoujiaMo(String type);
  
  public RouJiaMo sell(String type) {
    RouJiaMo roujiamo = createRouJiaMo(type);
    ...
  }
}


/**
 * 西安肉夹馍店
 * 
 * @author zhy
 * 
 */
public class XianRouJiaMoStore extends RoujiaMoStore
{
	@Override
	public RouJiaMo createRouJiaMo(String type)
	{
		RouJiaMo rouJiaMo = null;
		if (type.equals("Suan"))
		{
			rouJiaMo = new XianSuanRouJiaMo();
 
		} else if (type.equals("Tian"))
		{
			rouJiaMo = new XianTianRouJiaMo();
		} else if (type.equals("La"))
		{
			rouJiaMo = new XianLaRouJiaMo();
		}
		return rouJiaMo;
	}
}
```

#### 抽象工厂模式

```java
public interface RouJiaMoFactory
{
  public Meat createMeat();
  
	public YuanLiao createYuanliao();
}



/**
 * 根据西安当地特色，提供这两种材料
 * @author zhy
 *
 */
public class XianRouJiaMoYLFactroy implements RouJiaMoYLFactroy
{
 
	@Override
	public Meat createMeat()
	{
		return new FreshMest();
	}
 
	@Override
	public YuanLiao createYuanliao()
	{
		return new XianTeSeYuanliao();
	}
}


public abstract class RouJiaMo
{
	protected String name;
 
	/**
	 * 准备工作
	 */
	public final void prepare(RouJiaMoYLFactroy ylFactroy)
	{
		Meat meat = ylFactroy.createMeat();
		YuanLiao yuanliao = ylFactroy.createYuanliao();
		System.out.println("使用官方的原料" + meat + " , " + yuanliao + "作为原材料制作肉夹馍 ");
	}
 
	/**
	 * 使用你们的专用袋-包装
	 */
	public final void pack()
	{
		System.out.println("肉夹馍-专用袋-包装");
	}
 
	/**
	 * 秘制设备-烘烤2分钟
	 */
	public final void fire()
	{
		System.out.println("肉夹馍-专用设备-烘烤");
	}
}
```

### 建造者模式

- 说明

建造者模式是创建模式，可以将internal representation 与产品的生产过程分隔开来，从而使一个建造过程生成具有不同的internal representation的产品对象。

- 场景

用户去汽车店买汽车，汽车店需要根据用户的需求提供对用的汽车。

对比与工厂模式，建造者模式一般用来创建更复杂的对象

工厂模式：是把创建对象的过程放在工厂类中，由工厂提交产品。

建造者模式：建造者类提供组件的制造，而具体建造过程交给导演类，由导演类负责将各个组件按特定的规则组建为产品，然后交给客户。

- 代码

```java
public abstract class Builder {
  
  public abstract void setPart(String name, String type);
  
  public abstract Product getProduct();
} 

public class ConcreteBuilder extends Builder {

  private Product product = new Product();

  @Override
  public void setPart(String name, String type) {
    product.setName(name);
    product.setType(type);
  }

  @Override
  public Product getProduct() {
    return product;
  }
}

 // 店长
 Director director = new Director();
 // 得到宝马汽车，内部实现提取宝马汽车的详情操作
 Product product = director.getBProduct();
 // 展示汽车信息
 product.showProduct();
```

### 原型模式

- 用途：

用来创建重复的对象，同时保证性能，提供了一种创建对象的最佳方式。

- 使用环境：

当创建对象的代价较高时使用。可以在一个对象被创建以后，缓存该对象，在下一个请求时返回它的克隆，减少数据库的调用。

1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

- 使用：

实现Cloneable接口重写clone方法。

- 代码

```java
// 创建一个实现Cloneable接口的抽象类
public abstract class Shape implements Cloneable {
   
   private String id;
   protected String type;
   
   abstract void draw();
   
   public String getType(){
      return type;
   }
   
   public String getId() {
      return id;
   }
   
   public void setId(String id) {
      this.id = id;
   }
   
   public Object clone() {
      Object clone = null;
      try {
         clone = super.clone();
      } catch (CloneNotSupportedException e) {
         e.printStackTrace();
      }
      return clone;
   }
}

// 创建以上抽象类的实体类扩展
public class Rectangle extends Shape {
  public Rectangle() {
    type = "Rectangle";
  }
  @Override
  public void draw() {
    // do something;
  }
}

//创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中

public class ShapeCache {
    
   private static Hashtable<String, Shape> shapeMap 
      = new Hashtable<String, Shape>();
 
   public static Shape getShape(String shapeId) {
      Shape cachedShape = shapeMap.get(shapeId);
      return (Shape) cachedShape.clone();
   }
 
// 对每种形状都运行数据库查询，并创建该形状
// shapeMap.put(shapeKey, shape);
// 例如，我们要添加三种形状
		public static void loadCache() {
      Circle circle = new Circle();
      circle.setId("1");
      shapeMap.put(circle.getId(),circle);

      Square square = new Square();
      square.setId("2");
      shapeMap.put(square.getId(),square);

      Rectangle rectangle = new Rectangle();
      rectangle.setId("3");
      shapeMap.put(rectangle.getId(),rectangle);
  	}
}
// 获取存储在Hashtable中的形状克隆。
public class PrototypePatternDemo {
   public static void main(String[] args) {
      ShapeCache.loadCache();
 // 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。
      Shape clonedShape = (Shape) ShapeCache.getShape("1");
      System.out.println("Shape : " + clonedShape.getType());        
 
      Shape clonedShape2 = (Shape) ShapeCache.getShape("2");
      System.out.println("Shape : " + clonedShape2.getType());        
 
      Shape clonedShape3 = (Shape) ShapeCache.getShape("3");
      System.out.println("Shape : " + clonedShape3.getType());        
   }
}
```

- 在实例化时将所有实体类从数据库中获取生成并存在hashtable中，然后在调用时通过该hashtable获得对应实例的克隆。

## 结构型模式

### 适配器模式 

Adapter Pattern

- 功能：将一个类的接口转换为客户期望的另一个接口，将原本不兼容的类能够相互合作。
- 解决：使用户接口与厂商接口实现解耦，实现间接依赖。

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/Center.jpeg)

- 代码：

```java
// 客户端需要的接口
public interface V5Power 
{
  public int provideV5Power();
}

// 厂商提供的接口
public class V220Power
{
  public int provideV220Porwe();
}

// 适配器
public class V5PowerAdapter implements V5Power
{
  private V220Power v220Power;
  
  public V5PowerAdapter(V220Power v220Power) {
    this.v220Power = v220Power;
  } // 构造函数初始化厂商类。
  
  @Override
	public int provideV5Power()
	{
		int power = v220Power.provideV220Power() ;
		//power经过各种操作-->5 
		System.out.println("适配器：我悄悄的适配了电压。");
		return 5 ; 
	}
}
```

### 桥接模式 

Bridge Pattern

![桥接模式的 UML 图](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/20201015-bridge.svg)

- 目的：将抽象与实现分离，使它们能够独立变化
- 解决：在有多种变化可能的情况下，用继承可能会造成类爆炸，扩展不灵活。
- **何时使用：**实现系统可能有多个角度分类，每一种角度都可能变化。
- **如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。
- **关键代码：**抽象类依赖实现类。

- 代码实现

```java
// 创建桥接实现接口
public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);
}

// 创建实现了 DrawAPI 接口的实体桥接实现类。 
public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: red, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}
public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: green, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}

// 使用 DrawAPI 接口创建抽象类 Shape。
public abstract class Shape {
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();  
}
// 创建实现了 Shape 抽象类的实体类。
public class Circle extends Shape {
   private int x, y, radius;
 
   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }
 
   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
// 使用 Shape 和 DrawAPI 类画出不同颜色的圆。
public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());
 
      redCircle.draw();
      greenCircle.draw();
   }
}
```

### 装饰者模式 

Decorator Pattern

- 体现原则：开闭原则：对扩展开放，对修改关闭。
- 作用：当需要给某个类添加一些辅助功能，并且不改变原来的类的代码。

- 实现

```java
// 装备接口
public interface IEquip 
{
  public int calAtk();
  
  public String desc();
}

//
/**
 * 武器实现
 * 攻击力20
 * @author zhy
 */
public class ArmEquip implements IEquip
{
	@Override
	public int caculateAttack()
	{
		return 20;
	}
 
	@Override
	public String description()
	{
		return "屠龙刀";
	}
}
 
/**
 * 戒指实现
 * 攻击力 5
 * @author zhy
 *
 */
public class RingEquip implements IEquip
{
	@Override
	public int caculateAttack()
	{
		return 5;
	}
 
	@Override
	public String description()
	{
		return "圣战戒指";
	}
}

/**
 * 装饰品的接口，继承装备
 * @author zhy
 *
 */
public interface IEquipDecorator extends IEquip
{	
}
/**
 * 蓝宝石装饰品
 * 每颗攻击力+5
 * @author zhy
 * 
 */
public class BlueGemDecorator implements IEquipDecorator
{
	/**
	 * 每个装饰品维护一个装备
	 */
	private IEquip equip;
	public BlueGemDecorator(IEquip equip)
	{
		this.equip = equip;
	}
	@Override
	public int caculateAttack()
	{
		return 5 + equip.caculateAttack();
	}
	@Override
	public String description()
	{
		return equip.description() + "+ 蓝宝石";
	}
}

// 使用
package com.zhy.pattern.decorator;
 
public class Test
{
	public static void main(String[] args)
	{
		// 一个镶嵌2颗红宝石，1颗蓝宝石的靴子
		System.out.println(" 一个镶嵌2颗红宝石，1颗蓝宝石的靴子");
		IEquip equip = new RedGemDecorator(new RedGemDecorator(new BlueGemDecorator(new ShoeEquip())));
		System.out.println("攻击力  : " + equip.caculateAttack());
		System.out.println("描述 :" + equip.description());
		System.out.println("-------");
		// 一个镶嵌1颗红宝石，1颗蓝宝石的武器
		System.out.println(" 一个镶嵌1颗红宝石，1颗蓝宝石,1颗黄宝石的武器");
		equip = new RedGemDecorator(new BlueGemDecorator(new YellowGemDecorator(new ArmEquip())));
		System.out.println("攻击力  : " + equip.caculateAttack());
		System.out.println("描述 :" + equip.description());
		System.out.println("-------");
	}
}
```

- Java api使用： java流

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/Center-20220504203345790.jpeg)

### 组合模式 

Composite Pattern

- 用于把一组相似的对象当作一个单一的对象，创建了对象组的树形结构，以表示整体-部分的层次关系，组合模式使用户对单个对象和组合对象的使用具有一致性。

![组合模式的 UML 图](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/20210817-composite-composite.svg)

- 代码

```java
public class Employee {
   private String name;
   private String dept;
   private int salary;
   private List<Employee> subordinates;
 
   //构造函数
   public Employee(String name,String dept, int sal) {
      this.name = name;
      this.dept = dept;
      this.salary = sal;
      subordinates = new ArrayList<Employee>();
   }
 
   public void add(Employee e) {
      subordinates.add(e);
   }
 
   public void remove(Employee e) {
      subordinates.remove(e);
   }
 
   public List<Employee> getSubordinates(){
     return subordinates;
   }
 
   public String toString(){
      return ("Employee :[ Name : "+ name 
      +", dept : "+ dept + ", salary :"
      + salary+" ]");
   }   
}
public class CompositePatternDemo {
   public static void main(String[] args) {
      Employee CEO = new Employee("John","CEO", 30000);
 
      Employee headSales = new Employee("Robert","Head Sales", 20000);
 
      Employee headMarketing = new Employee("Michel","Head Marketing", 20000);
 
      Employee clerk1 = new Employee("Laura","Marketing", 10000);
      Employee clerk2 = new Employee("Bob","Marketing", 10000);
 
      Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
      Employee salesExecutive2 = new Employee("Rob","Sales", 10000);
 
      CEO.add(headSales);
      CEO.add(headMarketing);
 
      headSales.add(salesExecutive1);
      headSales.add(salesExecutive2);
 
      headMarketing.add(clerk1);
      headMarketing.add(clerk2);
 
      //打印该组织的所有员工
      System.out.println(CEO); 
      for (Employee headEmployee : CEO.getSubordinates()) {
         System.out.println(headEmployee);
         for (Employee employee : headEmployee.getSubordinates()) {
            System.out.println(employee);
         }
      }        
   }
}
```

即：对象中包含对象。如：组织中包含大量人员

### 外观模式 

Facade Pattern

- 定义：提供一个统一的接口，用来访问子系统中的一群接口。即用“外观”定义一个高层的接口，让子系统更容易使用。

- 外观模式：一般用于需要简化一个很大的接口，或者一群复杂的接口的时候。

![image-20220504205851781](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220504205851781.png)

### 享元模式 

Flyweight Pattern

- 目的：减少创建对象的数量，以减少内存的占用并提高性能。
- 尝试重用现有同类对象，如果未找到匹配的对象，则创建新对象。
- 何时使用：1. 系统中有大量对象。 2. 这些对象消耗大量内存。 3. 这些对象的状态可以外部化。 4. 这些对象可以分为多组。5、系统不依赖于这些对象身份，这些对象是不可分辨的。
- **如何解决：**用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。
- **关键代码：**用 HashMap 存储这些对象。

```java
// 创建一个接口
public interface Shape {
   void draw();
}

// 创建实现接口的实现类
public class Circle implements Shape {
   private String color;
   private int x;
   private int y;
   private int radius;
   public Circle(String color){
      this.color = color;     
   }
   public void setX(int x) {
      this.x = x;
   }
   public void setY(int y) {
      this.y = y;
   }
   public void setRadius(int radius) {
      this.radius = radius;
   }
   @Override
   public void draw() {
      System.out.println("Circle: Draw() [Color : " + color 
         +", x : " + x +", y :" + y +", radius :" + radius);
   }
}
// 创建一个工厂，生成实体类对象。
public class ShapeFactory {
   private static final HashMap<String, Shape> circleMap = new HashMap<>();
   public static Shape getCircle(String color) {
      Circle circle = (Circle)circleMap.get(color);
      if(circle == null) {
         circle = new Circle(color);
         circleMap.put(color, circle);
         System.out.println("Creating circle of color : " + color);
      }
      return circle;
   }
}
// 使用工厂通过传递颜色信息获取实体类对象
public class FlyweightPatternDemo {
   private static final String colors[] = 
      { "Red", "Green", "Blue", "White", "Black" };
   public static void main(String[] args) {
 
      for(int i=0; i < 20; ++i) {
         Circle circle = 
            (Circle)ShapeFactory.getCircle(getRandomColor());
         circle.setX(getRandomX());
         circle.setY(getRandomY());
         circle.setRadius(100);
         circle.draw();
      }
   }
   private static String getRandomColor() {
      return colors[(int)(Math.random()*colors.length)];
   }
   private static int getRandomX() {
      return (int)(Math.random()*100 );
   }
   private static int getRandomY() {
      return (int)(Math.random()*100);
   }
}
```

- 核心：通过工厂来维护一个HashMap，根据传入的key获取对象，如果没获取到则创建。（原型模式类似，都是维护一个表保存对象，但是原型模式获取对象的克隆，是用来创建新对象，而享元模式是结构型模式，用来重用对象）

### 代理模式 

Proxy Pattern

- Spring aop
- 1. 和适配器模式区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变代理类的接口。
- 2. 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

![代理模式的 UML 图](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/20211025-proxy.svg)

```java
public interface Image() {
  void display();
}

public class RealImage implements Image {
 
   private String fileName;
 
   public RealImage(String fileName){
      this.fileName = fileName;
      loadFromDisk(fileName);
   }
 
   @Override
   public void display() {
      System.out.println("Displaying " + fileName);
   }
 
   private void loadFromDisk(String fileName){
      System.out.println("Loading " + fileName);
   }
}

public class ProxyImage implements Image{
 
   private RealImage realImage;
   private String fileName;
   public ProxyImage(String fileName){
      this.fileName = fileName;
   }
   @Override
   public void display() {
      if(realImage == null){
         realImage = new RealImage(fileName);
      }
      realImage.display();
   }
}

public class ProxyPatternDemo {
   
   public static void main(String[] args) {
      Image image = new ProxyImage("test_10mb.jpg");

      // 图像将从磁盘加载
      image.display(); 
      System.out.println("");
      // 图像不需要从磁盘加载
      image.display();  
   }
}
```

初次调用代理类时创建对象，用于对象创建开销大，或者某些操作需要安全控制

实现是在访问对象时加上一个对此对象的访问层。

## 行为型模式

### 模板方法模式 

Template Method Pattern

- 定义：定义一些算法骨架，使子类可以不改变算法结构的情况下改变算法的步骤。

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/SouthEast.jpeg)

```java
package com.zhy.pattern.template;
// 超类
public abstract class Worker
{
	protected String name;
 
	public Worker(String name)
	{
		this.name = name;
	}
 
	/**
	 * 记录一天的工作
	 */
	public final void workOneDay()
	{
 
		System.out.println("-----------------work start ---------------");
		enterCompany();
		computerOn();
		work();
		computerOff();
		exitCompany();
		System.out.println("-----------------work end ---------------");
 
	}
 
	/**
	 * 工作
	 */
	public abstract void work();
 
	/**
	 * 关闭电脑
	 */
	private void computerOff()
	{
		System.out.println(name + "关闭电脑");
	}
 
	/**
	 * 打开电脑
	 */
	private void computerOn()
	{
		System.out.println(name + "打开电脑");
	}
 
	/**
	 * 进入公司
	 */
	public void enterCompany()
	{
		System.out.println(name + "进入公司");
	}
 
	/**
	 * 离开公司
	 */
	public void exitCompany()
	{
		System.out.println(name + "离开公司");
	}
 
}
// 子类
package com.zhy.pattern.template;
 
public class ITWorker extends Worker
{
 
	public ITWorker(String name)
	{
		super(name);
	}
 
	@Override
	public void work()
	{
		System.out.println(name + "写程序-测bug-fix bug");
	}
 
}

// 带钩子的超类
	public boolean isNeedPrintDate()
	{
		return false;
	}
	/**
	 * 离开公司
	 */
	public void exitCompany()
	{
		if (isNeedPrintDate())
		{
			System.out.print(new Date().toLocaleString()+"-->");
		}
		System.out.println(name + "离开公司");
	}
// 使用钩子的子类
 
public class ITWorker extends Worker
{
 
	public ITWorker(String name)
	{
		super(name);
	}
 
	@Override
	public void work()
	{
		System.out.println(name + "写程序-测bug-fix bug");
	}
 
	@Override
	public boolean isNeedPrintDate()
	{
		return true;
	}
	
}
```

主要用法：当一项工作有多项共同的内容，可以建立一个抽象父类来实现这些方法，不一样的方法可以使用抽象方法交给子类去实现。

可以创建一个钩子让特定的子类实现特定的功能。

### 命令模式 

Command Pattern

- 核心：把命令封装成类，对于命令执行者不需要知道现在执行的具体是什么命令。

- 目的： 将动作请求者与动作执行者解耦

![在这里插入图片描述](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Lus5LiA55u05Zyo6Lev5LiK,size_20,color_FFFFFF,t_70,g_se,x_16.png)

```java
/**
 * 功能：命令的抽象
 */
public interface ICommand {

    void execute();

}

/**
 * 功能：具体的命令
 */
public class ConcreteCommand implements ICommand{

    Receiver receiver = new Receiver();

    @Override
    public void execute() {
        receiver.action();
    }
}

/**
 * 功能：命令接收者
 */
public class Receiver {

    public void action() {
        System.out.println("具体执行");
    }
}

/**
 * 功能：命令请求者
 */
public class Invoker {

    private ICommand iCommand;

    public Invoker(ICommand iCommand) {
        this.iCommand = iCommand;
    }

    public void action() {
        iCommand.execute();
    }
}


public class Tests {

    public static void main(String[] args) {
        ICommand command = new ConcreteCommand();
        Invoker invoker = new Invoker(command);
        invoker.action();
    }
}
```

jdk中的使用：

Runnable：相当于命令的抽象

优点：通过引入命令的抽象接口，实现命令与执行的解耦

扩展性好，可以容易的增加新命令

缺点：命令类可能会过多。

### 迭代器模式 

Iterator Pattern

- Java和.Net中常用模式，用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

- 意图：提供一种方法顺序访问一个聚合对象中的各个元。

![迭代器模式的 UML 图](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/202107-23-iterator-pattern.png)

```java
// 接口
public interface Iterator {
   public boolean hasNext();
   public Object next();
}
public interface Container {
   public Iterator getIterator();
}

// 创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator。
public class NameRepository implements Container {
   public String[] names = {"Robert" , "John" ,"Julie" , "Lora"};
 
   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }
   private class NameIterator implements Iterator {
      int index;
      @Override
      public boolean hasNext() {
         if(index < names.length){
            return true;
         }
         return false;
      }
      @Override
      public Object next() {
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }     
   }
}
// 使用 NameRepository 来获取迭代器，并打印名字。
public class IteratorPatternDemo {
   
   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();
 
      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println("Name : " + name);
      }  
   }
}
```

1. 构建一个迭代器接口和一个获取迭代器的接口
2. 需要迭代的类中实现获取迭代器接口，内部类实现迭代器接口

### 观察者模式

Observer Pattern

- 定义：定义了对象之间的一对多的依赖，这样一来，当一个对象发生改变时，它的所有依赖者都会收到通知并自动更新。

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/Center-20220507215123288.jpeg)

```java
public interface Subject
{
  /**
  * 主题接口，所有主题必须实现此接口
  *	注册一个观察者
  *
  */
  public void registerObserver(Observer observer);
  
  // 移除一个观察者
  public void removeObserver(Observer observer);
    
  // 提醒所有观察者
	public void notifyObservers();
    
}

// 观察者实现此接口
public interface Observer
{
  public void update(String msg)
}

// 服务号的实现
public class ObjectFor3D implements Subject
{
	private List<Observer> observers = new ArrayList<Observer>();
	/**
	 * 3D彩票的号码
	 */
	private String msg;
 
	@Override
	public void registerObserver(Observer observer)
	{
		observers.add(observer);
	}
 
	@Override
	public void removeObserver(Observer observer)
	{
		int index = observers.indexOf(observer);
		if (index >= 0)
		{
			observers.remove(index);
		}
	}
 
	@Override
	public void notifyObservers()
	{
		for (Observer observer : observers)
		{
			observer.update(msg);
		}
	}
 
	/**
	 * 主题更新消息
	 * 
	 * @param msg
	 */
	public void setMsg(String msg)
	{
		this.msg = msg;
		// 提醒
		notifyObservers();
	}
 
}
// 使用者
package com.zhy.pattern.observer;
 
public class Observer1 implements Observer
{
 
	private Subject subject;
 
	public Observer1(Subject subject)
	{
		this.subject = subject;
		subject.registerObserver(this);
	}
 
	@Override
	public void update(String msg)
	{
		System.out.println("observer1 得到 3D 号码  -->" + msg + ", 我要记下来。");
	}
 
}

package com.zhy.pattern.observer;
 
public class Observer2 implements Observer
{
	private Subject subject ; 
	
	public Observer2(Subject subject)
	{
		this.subject = subject  ;
		subject.registerObserver(this);
	}
	
	@Override
	public void update(String msg)
	{
		System.out.println("observer2 得到 3D 号码 -->" + msg + "我要告诉舍友们。");
	}
}

public class Test
{
	public static void main(String[] args)
	{
		//模拟一个3D的服务号
		ObjectFor3D subjectFor3d = new ObjectFor3D();
		//客户1
		Observer observer1 = new Observer1(subjectFor3d);
		Observer observer2 = new Observer2(subjectFor3d);
 
		subjectFor3d.setMsg("20140420的3D号码是：127" );
		subjectFor3d.setMsg("20140421的3D号码是：333" );
		
	}
}
observer1 得到 3D 号码  -->20140420的3D号码是：127, 我要记下来。
observer2 得到 3D 号码 -->20140420的3D号码是：127我要告诉舍友们。
observer1 得到 3D 号码  -->20140421的3D号码是：333, 我要记下来。
observer2 得到 3D 号码 -->20140421的3D号码是：333我要告诉舍友们。
```

### 中介者模式

Mediator Pattern

- 目的：封装一系列的对象交互，松耦合，使各对象不需要显示地相互引用，也可以独立的 改变他们之间的交互。
- MVC框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。

**优点：** 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。

![image-20220508210353397](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/image-20220508210353397.png)

```java
import java.util.Date;
 
public class ChatRoom {
   public static void showMessage(User user, String message){
      System.out.println(new Date().toString()
         + " [" + user.getName() +"] : " + message);
   }
}

public class User {
   private String name;
 
   public String getName() {
      return name;
   }
 
   public void setName(String name) {
      this.name = name;
   }
 
   public User(String name){
      this.name  = name;
   }
 
   public void sendMessage(String message){
      ChatRoom.showMessage(this,message);
   }
}

public class MediatorPatternDemo {
   public static void main(String[] args) {
      User robert = new User("Robert");
      User john = new User("John");
 
      robert.sendMessage("Hi! John!");
      john.sendMessage("Hello! Robert!");
   }
}
```

### 备忘录模式 

Memento Pattern

意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

- 通过一个备忘录类专门存储对象状态

- **如何解决：**通过一个备忘录类专门存储对象状态。

  **关键代码：**客户不与备忘录类耦合，与备忘录管理类耦合。

  **应用实例：** 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctrl + z。 4、IE 中的后退。 5、数据库的事务管理

![备忘录模式的 UML 图](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/memento_pattern_uml_diagram.jpg)

```java
// Memento 包含了要被恢复的对象的状态
public class Memento {

	private String state;
	
	public Memento(String state) {
	    this.state = state;
	}
	
	public String getState() {
	    return state;
	}
	
	public void setState(String state) {
	    this.state = state;
	}
}
// 创建并在Memento中存储状态
public class Originator {

    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public Memento setSateToMemento() {
        return new Memento(state);
    }

    public String getStateFromMemento(Memento memento) {
        return memento.getState();
    }
}
// 负责从Memento中恢复对象
public class CareTaker {

    private List<Memento> mementoList = new ArrayList<Memento>();

    public void add(Memento memento) {
        mementoList.add(memento);
    }

    public Memento get(int index) {
        return mementoList.get(index);
    }
}
```

### 解释器模式

可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。

这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

![解释器模式的 UML 图](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/interpreter_pattern_uml_diagram.jpg)

### 状态模式

State Pattern

![状态模式的 UML 图](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/state_pattern_uml_diagram.png)

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/Center.jpeg)

```java
public interface State {
  public void doAction(Context context);
}

// 定义两个状态实现State接口，并实现操作 （售货机状态
public class StartState implements State {
 
   public void doAction(Context context) {
      System.out.println("Player is in start state");
      context.setState(this); 
   }
 
   public String toString(){
      return "Start State";
   }
}

public class StopState implements State {
 
   public void doAction(Context context) {
      System.out.println("Player is in stop state");
      context.setState(this); 
   }
 
   public String toString(){
      return "Stop State";
   }
}

// 创建包含状态的内容（售货机
public class Context {
  // 当前状态
   private State state;
 
   public Context(){
      state = null;
   }
 	// 设置状态
   public void setState(State state){
      this.state = state;     
   }
 
   public State getState(){
      return state;
   }
}
// 使用 Context 来查看当状态 State 改变时的行为变化。
public class StatePatternDemo {
   public static void main(String[] args) {
      Context context = new Context();
 
      StartState startState = new StartState();
      startState.doAction(context);
 
      System.out.println(context.getState().toString());
 
      StopState stopState = new StopState();
      stopState.doAction(context);
 
      System.out.println(context.getState().toString());
   }
}
```



### 策略模式

Strategy Pattern

![img](https://alcor-1306883605.cos.ap-shanghai.myqcloud.com/my/Center.png)

- 定义：定义算法簇，分别封装起来，并让它们可以相互替换，解耦合

```java
// 创建一个策略接口。
public interface Strategy {
   public int doOperation(int num1, int num2);
}

// 创建实现接口的实体类。
public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;
   }
}
public class OperationSubtract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;
   }
}
public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;
   }
}
// 创建context类，传入对应的策略。
public class Context {
   private Strategy strategy;
 
   public Context(Strategy strategy){
      this.strategy = strategy;
   }
 
   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);
   }
}
// 使用 Context 来查看当它改变策略 Strategy 时的行为变化。
public class StrategyPatternDemo {
   public static void main(String[] args) {
      Context context = new Context(new OperationAdd());    
      System.out.println("10 + 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationSubtract());      
      System.out.println("10 - 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationMultiply());    
      System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
   }
}


### 责任链模式

Chain of Responsibility Pattern

![责任链模式的 UML 图](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/913/2021-chain-of-responsibility.svg)

```java
// 日志记录器 构建抽象日志记录类
public abstract class AbstractLogger {
   public static int INFO = 1;
   public static int DEBUG = 2;
   public static int ERROR = 3;
 
   protected int level;
 
   //责任链中的下一个元素
   protected AbstractLogger nextLogger;
 
   public void setNextLogger(AbstractLogger nextLogger){
      this.nextLogger = nextLogger;
   }
   public void logMessage(int level, String message){
      if(this.level <= level){
         write(message);
      }
      if(nextLogger !=null){
         nextLogger.logMessage(level, message);
      }
   }
   abstract protected void write(String message);
}
// 日志类型实体类
public class ConsoleLogger extends AbstractLogger {
 
   public ConsoleLogger(int level){
      this.level = level;
   }
 
   @Override
   protected void write(String message) {    
      System.out.println("Standard Console::Logger: " + message);
   }
}
public class ErrorLogger extends AbstractLogger {
 
   public ErrorLogger(int level){
      this.level = level;
   }
 
   @Override
   protected void write(String message) {    
      System.out.println("Error Console::Logger: " + message);
   }
}
// 创建与使用
public class ChainPatternDemo {
   // 创建日志链
   private static AbstractLogger getChainOfLoggers(){
 
      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);
      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);
      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);
 
      errorLogger.setNextLogger(fileLogger);
      fileLogger.setNextLogger(consoleLogger);
 
      return errorLogger;  
   }
 
   public static void main(String[] args) {
      AbstractLogger loggerChain = getChainOfLoggers();
 
      loggerChain.logMessage(AbstractLogger.INFO, "This is an information.");
 
      loggerChain.logMessage(AbstractLogger.DEBUG, 
         "This is a debug level information.");
 
      loggerChain.logMessage(AbstractLogger.ERROR, 
         "This is an error information.");
   }
}


### 访问者模式

Visitor Pattern

- 目的：将数据结构与数据操作分离。

- 在被访问的类里面加一个对外提供接待访问者的接口。

- 在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。

- **优点：** 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。

  **缺点：** 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。

  ![在这里插入图片描述](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/913/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2QzMDM1Nzc1NjI=,size_16,color_FFFFFF,t_70.jpeg)

![访问者模式的 UML 图](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/913/visitor_pattern_uml_diagram.jpg)

```java
public interface company {
  
	String create(Paper paper);
  
  String create(Cuprum cuprum);
}

public class ArtCompany implements company {
  @Override
  public String create(Papaer paper){
    return "image";
  }
  
  @Override
  public String create(Cuprum cuprum){
    return "cuprum";
  }
}


```

https://blog.csdn.net/d303577562/article/details/118903874

# 其他

## ACM输入输出

### 多组输入，读取到文件尾

```java
import java.util.Scanner;

public class Main {
  Scanner scan = new Scanner(System.in);
  while (scan.hasNext()) {
    // scan.hasNextInt();
    // scan.hasNextDouble();
    // scan.hasNextLine();
  }
}
```

### 输入输出

```java
import java.io.BufferedInputStream;

Scanner scan = new Scanner(new BufferedInputStream(System.in));
Scanner scan = new Scanner(System.in);

int n = scan.nextInt();
double f = scan.nextDouble();
String s = scan.next();

```

### java大数

```java
import java.math.BigInteger;
import java.math.BigDecimal;

public class Main{
  BigInteger a, b, ans;
  Scanner scan = new Scanner(System.in);
  a = scan.nextBigInteger;
  b = scan.nextBigInteger;
  ans = a.add(b); // a + b
  ans = a.subtract(b); // a - b
  ans = a.mod(n); // a % b
  ans = a.divide(b); // a / b
  ans = a.max(b);
  ans = a.multiply(b); // a * b
}
```



### 链表

```java
import java.util.Scanner;
import java.util.Stack;

/** 
*		对于一个链表L: L0->L1->...Ln-1->Ln,
*		反转成 L0->Ln->Ln-1->...->L2..
*		反转链表
**/
public class Main {
  static class LinkNode {
    int val;
    LinkNode node;
    public LinkNode(int val) {
      this.val = val;
    }
  }
  
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    String str = scanner.next().toString();
    // 转换为字符串数组
    String[] arr = str.split(",");
    // 初始化一个整数数组
    int[] ints = new int[arr.length];
    // 给整数数组赋值
    for (int j = 0; j < ints.length; j++) {
      ints[j] = Integer.parseInt(arr[j]);
    }
    Stack<LinkNode> stack = new Stach<>();
    LinkNode head = new LinkNode(0);
    LinkNode p = head;
    for (int i = 0; i < ints.length; i++) {
      p.next = new LinkNode(ints[i]);
      p = p.next;
      stack.add(p);
    }
    head = head.next;
    // 开始反转
    p = head;
    LinkNode q = stack.peek();
    while ((!p.equals(q)) && (!p.next.equals(q))) {
      q = stack.pop();
      q.next = p.next;
      p.next = q;
      p = p.next.next;
      q = stack.peek();
    }
    q.next = null;
    // 输出打印
    while (head != null) {
      if (head.next == null) {
        System.out.println( head.val);
      } else {
        System.out.println(head.val + ",");
      }
      head = head.next;
    }
  } 
}
```

### 树的输入

```java
// 判断是否为二叉树
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;
  
//题目描述
//给定一个二叉树，判断其是否是一个有效的二叉搜索树。
//假设一个二叉搜索树具有如下特征：
//节点的左子树只包含小于当前节点的数。
//节点的右子树只包含大于当前节点的数。
//所有左子树和右子树自身必须也是二叉搜索树。
//例如：
//输入：
//    5
//   / \
//  1   3
//     / \
//    4   6
//输出: false

public class Main{
  
}
```


mysql普通索引与组合索引